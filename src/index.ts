/**
 * Generated by orval v7.12.2 🍺
 * Do not edit manually.
 * VOICEVOX ENGINE OSS
 * VOICEVOX OSS の音声合成エンジンです。
 * OpenAPI spec version: latest
 */
/**
 * アクセント句ごとの情報。
 */
export interface AccentPhrase {
  /** アクセント箇所 */
  accent: number;
  /** 疑問系かどうか */
  is_interrogative?: boolean;
  /** モーラのリスト */
  moras: Mora[];
  /** アクセント句の末尾につく無音モーラ。null の場合は無音モーラを付けない。 */
  pause_mora?: Mora;
}

/**
 * 句読点などの無音時間。nullのときは無視される。デフォルト値はnull
 */
export type AudioQueryPauseLength = number | null;

/**
 * 音声合成用のクエリ。
 */
export interface AudioQuery {
  /** アクセント句のリスト */
  accent_phrases: AccentPhrase[];
  /** 全体の抑揚 */
  intonationScale: number;
  /** [読み取り専用]AquesTalk 風記法によるテキスト。音声合成用のクエリとしては無視される */
  kana?: string;
  /** 音声データの出力サンプリングレート */
  outputSamplingRate: number;
  /** 音声データをステレオ出力するか否か */
  outputStereo: boolean;
  /** 句読点などの無音時間。nullのときは無視される。デフォルト値はnull */
  pauseLength?: AudioQueryPauseLength;
  /** 句読点などの無音時間（倍率）。デフォルト値は1 */
  pauseLengthScale?: number;
  /** 全体の音高 */
  pitchScale: number;
  /** 音声の後の無音時間 */
  postPhonemeLength: number;
  /** 音声の前の無音時間 */
  prePhonemeLength: number;
  /** 全体の話速 */
  speedScale: number;
  /** 全体の音量 */
  volumeScale: number;
}

/**
 * 音声ライブラリの情報。
 */
export interface BaseLibraryInfo {
  /** 音声ライブラリのバイト数 */
  bytes: number;
  /** 音声ライブラリのダウンロードURL */
  download_url: string;
  /** 音声ライブラリの名前 */
  name: string;
  /** 音声ライブラリに含まれるキャラクターのリスト */
  speakers: LibrarySpeaker[];
  /** 音声ライブラリのUUID */
  uuid: string;
  /** 音声ライブラリのバージョン */
  version: string;
}

export interface BodySettingPostSettingPost {
  allow_origin?: string;
  cors_policy_mode: CorsPolicyMode;
}

export interface BodySingFrameF0SingFrameF0Post {
  frame_audio_query: FrameAudioQuery;
  score: Score;
}

export interface BodySingFrameVolumeSingFrameVolumePost {
  frame_audio_query: FrameAudioQuery;
  score: Score;
}

/**
 * CORSの許可モード。
 */
export type CorsPolicyMode = (typeof CorsPolicyMode)[keyof typeof CorsPolicyMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CorsPolicyMode = {
  all: 'all',
  localapps: 'localapps',
} as const;

/**
 * ダウンロード可能な音声ライブラリの情報。
 */
export interface DownloadableLibraryInfo {
  /** 音声ライブラリのバイト数 */
  bytes: number;
  /** 音声ライブラリのダウンロードURL */
  download_url: string;
  /** 音声ライブラリの名前 */
  name: string;
  /** 音声ライブラリに含まれるキャラクターのリスト */
  speakers: LibrarySpeaker[];
  /** 音声ライブラリのUUID */
  uuid: string;
  /** 音声ライブラリのバージョン */
  version: string;
}

/**
 * エンジン自体に関する情報。
 */
export interface EngineManifest {
  /** ブランド名 */
  brand_name: string;
  /** デフォルトのサンプリング周波数 */
  default_sampling_rate: number;
  /** 依存関係のライセンス情報 */
  dependency_licenses: LicenseInfo[];
  /** エンジンのフレームレート */
  frame_rate: number;
  /** エンジンのアイコンをBASE64エンコードしたもの */
  icon: string;
  /** マニフェストのバージョン */
  manifest_version: string;
  /** エンジン名 */
  name: string;
  /** エンジンが持つ機能 */
  supported_features: SupportedFeatures;
  /** エンジンが対応するvvlibのバージョン */
  supported_vvlib_manifest_version?: string;
  /** エンジンの利用規約 */
  terms_of_service: string;
  /** エンジンのアップデート情報 */
  update_infos: UpdateInfo[];
  /** エンジンのURL */
  url: string;
  /** エンジンのUUID */
  uuid: string;
}

/**
 * フレームごとの音声合成用のクエリ。
 */
export interface FrameAudioQuery {
  /** フレームごとの基本周波数 */
  f0: number[];
  /** 音声データの出力サンプリングレート */
  outputSamplingRate: number;
  /** 音声データをステレオ出力するか否か */
  outputStereo: boolean;
  /** 音素のリスト */
  phonemes: FramePhoneme[];
  /** フレームごとの音量 */
  volume: number[];
  /** 全体の音量 */
  volumeScale: number;
}

/**
 * 音符のID
 */
export type FramePhonemeNoteId = string | null;

/**
 * 音素の情報。
 */
export interface FramePhoneme {
  /** 音素のフレーム長 */
  frame_length: number;
  /** 音符のID */
  note_id?: FramePhonemeNoteId;
  /** 音素 */
  phoneme: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * インストール済み音声ライブラリの情報。
 */
export interface InstalledLibraryInfo {
  /** 音声ライブラリのバイト数 */
  bytes: number;
  /** 音声ライブラリのダウンロードURL */
  download_url: string;
  /** 音声ライブラリの名前 */
  name: string;
  /** 音声ライブラリに含まれるキャラクターのリスト */
  speakers: LibrarySpeaker[];
  /** アンインストール可能かどうか */
  uninstallable: boolean;
  /** 音声ライブラリのUUID */
  uuid: string;
  /** 音声ライブラリのバージョン */
  version: string;
}

/**
 * 音声ライブラリに含まれるキャラクターの情報。
 */
export interface LibrarySpeaker {
  speaker: Speaker;
  speaker_info: SpeakerInfo;
}

/**
 * 依存ライブラリのライセンス情報。
 */
export interface LicenseInfo {
  /** 依存ライブラリのライセンス名 */
  license?: string;
  /** 依存ライブラリ名 */
  name: string;
  /** 依存ライブラリのライセンス本文 */
  text: string;
  /** 依存ライブラリのバージョン */
  version?: string;
}

/**
 * モーラ（子音＋母音）ごとの情報。
 */
export interface Mora {
  /** 子音の音素 */
  consonant?: string;
  /** 子音の長さ */
  consonant_length?: number;
  /** 音高 */
  pitch: number;
  /** 文字 */
  text: string;
  /** 母音の音素 */
  vowel: string;
  /** 母音の長さ */
  vowel_length: number;
}

/**
 * モーフィング相手としての情報。
 */
export interface MorphableTargetInfo {
  /** 指定したキャラクターに対してモーフィングの可否 */
  is_morphable: boolean;
}

/**
 * ID
 */
export type NoteId = string | null;

/**
 * 音符ごとの情報。
 */
export interface Note {
  /** 音符のフレーム長 */
  frame_length: number;
  /** ID */
  id?: NoteId;
  /** 音階 */
  key?: number;
  /** 音符の歌詞 */
  lyric: string;
}

/**
 * エラーを起こした箇所
 */
export type ParseKanaBadRequestErrorArgs = { [key: string]: string };

/**
 * 読み仮名のパースに失敗した。
 */
export interface ParseKanaBadRequest {
  /** エラーを起こした箇所 */
  error_args: ParseKanaBadRequestErrorArgs;
  /** エラー名

|name|description|
|---|---|
| UNKNOWN_TEXT | 判別できない読み仮名があります: {text} |
| ACCENT_TOP | 句頭にアクセントは置けません: {text} |
| ACCENT_TWICE | 1つのアクセント句に二つ以上のアクセントは置けません: {text} |
| ACCENT_NOTFOUND | アクセントを指定していないアクセント句があります: {text} |
| EMPTY_PHRASE | {position}番目のアクセント句が空白です |
| INTERROGATION_MARK_NOT_AT_END | アクセント句末以外に「？」は置けません: {text} |
| INFINITE_LOOP | 処理時に無限ループになってしまいました...バグ報告をお願いします。 | */
  error_name: string;
  /** エラーメッセージ */
  text: string;
}

/**
 * プリセット情報。
 */
export interface Preset {
  /** プリセットID */
  id: number;
  /** 全体の抑揚 */
  intonationScale: number;
  /** プリセット名 */
  name: string;
  /** 句読点などの無音時間 */
  pauseLength?: number;
  /** 句読点などの無音時間（倍率） */
  pauseLengthScale?: number;
  /** 全体の音高 */
  pitchScale: number;
  /** 音声の後の無音時間 */
  postPhonemeLength: number;
  /** 音声の前の無音時間 */
  prePhonemeLength: number;
  /** キャラクターのUUID */
  speaker_uuid: string;
  /** 全体の話速 */
  speedScale: number;
  /** スタイルID */
  style_id: number;
  /** 全体の音量 */
  volumeScale: number;
}

/**
 * 楽譜情報。
 */
export interface Score {
  /** 音符のリスト */
  notes: Note[];
}

/**
 * キャラクター情報
 */
export interface Speaker {
  /** 名前 */
  name: string;
  /** キャラクターのUUID */
  speaker_uuid: string;
  /** スタイルの一覧 */
  styles: SpeakerStyle[];
  /** キャラクターの対応機能 */
  supported_features?: SpeakerSupportedFeatures;
  /** キャラクターのバージョン */
  version: string;
}

/**
 * キャラクターの追加情報
 */
export interface SpeakerInfo {
  /** policy.md */
  policy: string;
  /** 立ち絵画像をbase64エンコードしたもの、あるいはURL */
  portrait: string;
  /** スタイルの追加情報 */
  style_infos: StyleInfo[];
}

/**
 * スタイルの種類。talk:音声合成クエリの作成と音声合成が可能。singing_teacher:歌唱音声合成用のクエリの作成が可能。frame_decode:歌唱音声合成が可能。sing:歌唱音声合成用のクエリの作成と歌唱音声合成が可能。
 */
export type SpeakerStyleType = (typeof SpeakerStyleType)[keyof typeof SpeakerStyleType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerStyleType = {
  talk: 'talk',
  singing_teacher: 'singing_teacher',
  frame_decode: 'frame_decode',
  sing: 'sing',
} as const;

/**
 * キャラクターのスタイル情報
 */
export interface SpeakerStyle {
  /** スタイルID */
  id: number;
  /** スタイル名 */
  name: string;
  /** スタイルの種類。talk:音声合成クエリの作成と音声合成が可能。singing_teacher:歌唱音声合成用のクエリの作成が可能。frame_decode:歌唱音声合成が可能。sing:歌唱音声合成用のクエリの作成と歌唱音声合成が可能。 */
  type?: SpeakerStyleType;
}

/**
 * モーフィング機能への対応。'ALL' は「全て許可」、'SELF_ONLY' は「同じキャラクター内でのみ許可」、'NOTHING' は「全て禁止」
 */
export type SpeakerSupportedFeaturesPermittedSynthesisMorphing =
  (typeof SpeakerSupportedFeaturesPermittedSynthesisMorphing)[keyof typeof SpeakerSupportedFeaturesPermittedSynthesisMorphing];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerSupportedFeaturesPermittedSynthesisMorphing = {
  ALL: 'ALL',
  SELF_ONLY: 'SELF_ONLY',
  NOTHING: 'NOTHING',
} as const;

/**
 * キャラクターの対応機能の情報
 */
export interface SpeakerSupportedFeatures {
  /** モーフィング機能への対応。'ALL' は「全て許可」、'SELF_ONLY' は「同じキャラクター内でのみ許可」、'NOTHING' は「全て禁止」 */
  permitted_synthesis_morphing?: SpeakerSupportedFeaturesPermittedSynthesisMorphing;
}

/**
 * スタイルの追加情報
 */
export interface StyleInfo {
  /** このスタイルのアイコンをbase64エンコードしたもの、あるいはURL */
  icon: string;
  /** スタイルID */
  id: number;
  /** このスタイルの立ち絵画像をbase64エンコードしたもの、あるいはURL */
  portrait?: string;
  /** サンプル音声をbase64エンコードしたもの、あるいはURL */
  voice_samples: string[];
}

/**
 * 対応しているデバイスの情報。
 */
export interface SupportedDevicesInfo {
  /** CPUに対応しているか */
  cpu: boolean;
  /** CUDA(Nvidia GPU)に対応しているか */
  cuda: boolean;
  /** DirectML(Nvidia GPU/Radeon GPU等)に対応しているか */
  dml: boolean;
}

/**
 * エンジンが持つ機能の一覧。
 */
export interface SupportedFeatures {
  /** 全体の抑揚の調整 */
  adjust_intonation_scale: boolean;
  /** モーラごとの音高の調整 */
  adjust_mora_pitch: boolean;
  /** 句読点などの無音時間の調整 */
  adjust_pause_length?: boolean;
  /** 音素ごとの長さの調整 */
  adjust_phoneme_length: boolean;
  /** 全体の音高の調整 */
  adjust_pitch_scale: boolean;
  /** 全体の話速の調整 */
  adjust_speed_scale: boolean;
  /** 全体の音量の調整 */
  adjust_volume_scale: boolean;
  /** 未知の英単語をカタカナ読みに変換 */
  apply_katakana_english?: boolean;
  /** 疑問文の自動調整 */
  interrogative_upspeak: boolean;
  /** 音声ライブラリのインストール・アンインストール */
  manage_library?: boolean;
  /** キャラクター情報のリソースをURLで返送 */
  return_resource_url?: boolean;
  /** 歌唱音声合成 */
  sing?: boolean;
  /** 2種類のスタイルでモーフィングした音声を合成 */
  synthesis_morphing: boolean;
}

/**
 * エンジンのアップデート情報。
 */
export interface UpdateInfo {
  /** 貢献者名 */
  contributors?: string[];
  /** アップデートの詳細についての説明 */
  descriptions: string[];
  /** エンジンのバージョン名 */
  version: string;
}

/**
 * 辞書のコンパイルに使われる情報。
 */
export interface UserDictWord {
  /** アクセント結合規則 */
  accent_associative_rule: string;
  /** アクセント型 */
  accent_type: number;
  /** 文脈ID */
  context_id?: number;
  /** 活用形 */
  inflectional_form: string;
  /** 活用型 */
  inflectional_type: string;
  /** モーラ数 */
  mora_count?: number;
  /** 品詞 */
  part_of_speech: string;
  /** 品詞細分類1 */
  part_of_speech_detail_1: string;
  /** 品詞細分類2 */
  part_of_speech_detail_2: string;
  /** 品詞細分類3 */
  part_of_speech_detail_3: string;
  /**
   * 優先度
   * @minimum 0
   * @maximum 10
   */
  priority: number;
  /** 発音 */
  pronunciation: string;
  /** 原形 */
  stem: string;
  /** 表層形 */
  surface: string;
  /** 読み */
  yomi: string;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * vvlib(VOICEVOX Library)に関する情報。
 */
export interface VvlibManifest {
  /** エンジンのブランド名 */
  brand_name: string;
  /** エンジン名 */
  engine_name: string;
  /** エンジンのUUID */
  engine_uuid: string;
  /** マニフェストバージョン */
  manifest_version: string;
  /** 音声ライブラリ名 */
  name: string;
  /** 音声ライブラリのUUID */
  uuid: string;
  /** 音声ライブラリバージョン */
  version: string;
}

/**
 * 品詞
 */
export type WordTypes = (typeof WordTypes)[keyof typeof WordTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WordTypes = {
  PROPER_NOUN: 'PROPER_NOUN',
  COMMON_NOUN: 'COMMON_NOUN',
  VERB: 'VERB',
  ADJECTIVE: 'ADJECTIVE',
  SUFFIX: 'SUFFIX',
} as const;

export type AccentPhrasesParams = {
  text: string;
  speaker: number;
  is_kana?: boolean;
  enable_katakana_english?: boolean;
  core_version?: string;
};

export type AudioQueryParams = {
  text: string;
  speaker: number;
  enable_katakana_english?: boolean;
  core_version?: string;
};

export type AudioQueryFromPresetParams = {
  text: string;
  preset_id: number;
  enable_katakana_english?: boolean;
  core_version?: string;
};

export type CancellableSynthesisParams = {
  speaker: number;
  enable_interrogative_upspeak?: boolean;
  core_version?: string;
};

export type DeletePresetParams = {
  /**
   * 削除するプリセットのプリセットID
   */
  id: number;
};

export type FrameSynthesisParams = {
  speaker: number;
  core_version?: string;
};

export type ImportUserDictWordsParams = {
  /**
   * 重複したエントリがあった場合、上書きするかどうか
   */
  override: boolean;
};

/**
 * インポートするユーザー辞書のデータ
 */
export type ImportUserDictWordsBody = { [key: string]: UserDictWord };

export type InitializeSpeakerParams = {
  speaker: number;
  /**
   * 既に初期化済みのスタイルの再初期化をスキップするかどうか
   */
  skip_reinit?: boolean;
  core_version?: string;
};

export type InstalledLibraries200 = { [key: string]: InstalledLibraryInfo };

export type IsInitializedSpeakerParams = {
  speaker: number;
  core_version?: string;
};

export type MoraDataParams = {
  speaker: number;
  core_version?: string;
};

export type MoraLengthParams = {
  speaker: number;
  core_version?: string;
};

export type MoraPitchParams = {
  speaker: number;
  core_version?: string;
};

export type MorphableTargetsParams = {
  core_version?: string;
};

export type MorphableTargets200Item = { [key: string]: MorphableTargetInfo };

export type MultiSynthesisParams = {
  speaker: number;
  /**
   * 疑問系のテキストが与えられたら語尾を自動調整する
   */
  enable_interrogative_upspeak?: boolean;
  core_version?: string;
};

export type SingFrameAudioQueryParams = {
  speaker: number;
  core_version?: string;
};

export type SingFrameF0Params = {
  speaker: number;
  core_version?: string;
};

export type SingFrameVolumeParams = {
  speaker: number;
  core_version?: string;
};

export type SingerInfoParams = {
  speaker_uuid: string;
  resource_format?: SingerInfoResourceFormat;
  core_version?: string;
};

export type SingerInfoResourceFormat =
  (typeof SingerInfoResourceFormat)[keyof typeof SingerInfoResourceFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SingerInfoResourceFormat = {
  base64: 'base64',
  url: 'url',
} as const;

export type SingersParams = {
  core_version?: string;
};

export type SpeakerInfoParams = {
  speaker_uuid: string;
  resource_format?: SpeakerInfoResourceFormat;
  core_version?: string;
};

export type SpeakerInfoResourceFormat =
  (typeof SpeakerInfoResourceFormat)[keyof typeof SpeakerInfoResourceFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerInfoResourceFormat = {
  base64: 'base64',
  url: 'url',
} as const;

export type SpeakersParams = {
  core_version?: string;
};

export type SupportedDevicesParams = {
  core_version?: string;
};

export type SynthesisParams = {
  speaker: number;
  /**
   * 疑問系のテキストが与えられたら語尾を自動調整する
   */
  enable_interrogative_upspeak?: boolean;
  core_version?: string;
};

export type SynthesisMorphingParams = {
  base_speaker: number;
  target_speaker: number;
  /**
   * @minimum 0
   * @maximum 1
   */
  morph_rate: number;
  /**
   * 疑問系のテキストが与えられたら語尾を自動調整する
   */
  enable_interrogative_upspeak?: boolean;
  core_version?: string;
};

export type GetUserDictWords200 = { [key: string]: UserDictWord };

export type AddUserDictWordParams = {
  /**
   * 言葉の表層形
   */
  surface: string;
  /**
   * 言葉の発音（カタカナ）
   */
  pronunciation: string;
  /**
   * アクセント型（音が下がる場所を指す）
   */
  accent_type: number;
  /**
   * PROPER_NOUN（固有名詞）、COMMON_NOUN（普通名詞）、VERB（動詞）、ADJECTIVE（形容詞）、SUFFIX（語尾）のいずれか
   */
  word_type?: WordTypes;
  /**
   * 単語の優先度（0から10までの整数）。数字が大きいほど優先度が高くなる。1から9までの値を指定することを推奨
   * @minimum 0
   * @maximum 10
   */
  priority?: number;
};

export type RewriteUserDictWordParams = {
  /**
   * 言葉の表層形
   */
  surface: string;
  /**
   * 言葉の発音（カタカナ）
   */
  pronunciation: string;
  /**
   * アクセント型（音が下がる場所を指す）
   */
  accent_type: number;
  /**
   * PROPER_NOUN（固有名詞）、COMMON_NOUN（普通名詞）、VERB（動詞）、ADJECTIVE（形容詞）、SUFFIX（語尾）のいずれか
   */
  word_type?: WordTypes;
  /**
   * 単語の優先度（0から10までの整数）。数字が大きいほど優先度が高くなる。1から9までの値を指定することを推奨。
   * @minimum 0
   * @maximum 10
   */
  priority?: number;
};

export type ValidateKanaParams = {
  /**
   * 判定する対象の文字列
   */
  text: string;
};

/**
 * ポータルページを返します。
 * @summary Get Portal Page
 */
export type getPortalPageResponse200 = {
  data: string;
  status: 200;
};

export type getPortalPageResponseSuccess = getPortalPageResponse200 & {
  headers: Headers;
};

export type getPortalPageResponse = getPortalPageResponseSuccess;

export const getGetPortalPageUrl = () => {
  return `/`;
};

export const getPortalPage = async (options?: RequestInit): Promise<getPortalPageResponse> => {
  const res = await fetch(getGetPortalPageUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getPortalPageResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getPortalPageResponse;
};

/**
 * テキストからアクセント句を得ます。

is_kanaが`true`のとき、テキストは次のAquesTalk 風記法で解釈されます。デフォルトは`false`です。
* 全てのカナはカタカナで記述される
* アクセント句は`/`または`、`で区切る。`、`で区切った場合に限り無音区間が挿入される。
* カナの手前に`_`を入れるとそのカナは無声化される
* アクセント位置を`'`で指定する。全てのアクセント句にはアクセント位置を1つ指定する必要がある。
* アクセント句末に`？`(全角)を入れることにより疑問文の発音ができる。
enable_katakana_englishが`true`のとき、テキスト中の読みが不明な英単語をカタカナ読みにします。デフォルトは`true`です。
is_kanaが`true`のとき、enable_katakana_englishの値は無視されます。
 * @summary テキストからアクセント句を得る
 */
export type accentPhrasesResponse200 = {
  data: AccentPhrase[];
  status: 200;
};

export type accentPhrasesResponse400 = {
  data: ParseKanaBadRequest;
  status: 400;
};

export type accentPhrasesResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type accentPhrasesResponseSuccess = accentPhrasesResponse200 & {
  headers: Headers;
};
export type accentPhrasesResponseError = (accentPhrasesResponse400 | accentPhrasesResponse422) & {
  headers: Headers;
};

export type accentPhrasesResponse = accentPhrasesResponseSuccess | accentPhrasesResponseError;

export const getAccentPhrasesUrl = (params: AccentPhrasesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/accent_phrases?${stringifiedParams}` : `/accent_phrases`;
};

export const accentPhrases = async (
  params: AccentPhrasesParams,
  options?: RequestInit
): Promise<accentPhrasesResponse> => {
  const res = await fetch(getAccentPhrasesUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: accentPhrasesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as accentPhrasesResponse;
};

/**
 * 新しいプリセットを追加します。
 * @summary Add Preset
 */
export type addPresetResponse200 = {
  data: number;
  status: 200;
};

export type addPresetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type addPresetResponseSuccess = addPresetResponse200 & {
  headers: Headers;
};
export type addPresetResponseError = addPresetResponse422 & {
  headers: Headers;
};

export type addPresetResponse = addPresetResponseSuccess | addPresetResponseError;

export const getAddPresetUrl = () => {
  return `/add_preset`;
};

export const addPreset = async (
  preset: Preset,
  options?: RequestInit
): Promise<addPresetResponse> => {
  const res = await fetch(getAddPresetUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(preset),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: addPresetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as addPresetResponse;
};

/**
 * 音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま音声合成に利用できます。各値の意味は`Schemas`を参照してください。
 * @summary 音声合成用のクエリを作成する
 */
export type audioQueryResponse200 = {
  data: AudioQuery;
  status: 200;
};

export type audioQueryResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type audioQueryResponseSuccess = audioQueryResponse200 & {
  headers: Headers;
};
export type audioQueryResponseError = audioQueryResponse422 & {
  headers: Headers;
};

export type audioQueryResponse = audioQueryResponseSuccess | audioQueryResponseError;

export const getAudioQueryUrl = (params: AudioQueryParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/audio_query?${stringifiedParams}` : `/audio_query`;
};

export const audioQuery = async (
  params: AudioQueryParams,
  options?: RequestInit
): Promise<audioQueryResponse> => {
  const res = await fetch(getAudioQueryUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: audioQueryResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as audioQueryResponse;
};

/**
 * 音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま音声合成に利用できます。各値の意味は`Schemas`を参照してください。
 * @summary 音声合成用のクエリをプリセットを用いて作成する
 */
export type audioQueryFromPresetResponse200 = {
  data: AudioQuery;
  status: 200;
};

export type audioQueryFromPresetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type audioQueryFromPresetResponseSuccess = audioQueryFromPresetResponse200 & {
  headers: Headers;
};
export type audioQueryFromPresetResponseError = audioQueryFromPresetResponse422 & {
  headers: Headers;
};

export type audioQueryFromPresetResponse =
  | audioQueryFromPresetResponseSuccess
  | audioQueryFromPresetResponseError;

export const getAudioQueryFromPresetUrl = (params: AudioQueryFromPresetParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/audio_query_from_preset?${stringifiedParams}`
    : `/audio_query_from_preset`;
};

export const audioQueryFromPreset = async (
  params: AudioQueryFromPresetParams,
  options?: RequestInit
): Promise<audioQueryFromPresetResponse> => {
  const res = await fetch(getAudioQueryFromPresetUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: audioQueryFromPresetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as audioQueryFromPresetResponse;
};

/**
 * @summary 音声合成する（キャンセル可能）
 */
export type cancellableSynthesisResponse200 = {
  data: Blob;
  status: 200;
};

export type cancellableSynthesisResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type cancellableSynthesisResponseSuccess = cancellableSynthesisResponse200 & {
  headers: Headers;
};
export type cancellableSynthesisResponseError = cancellableSynthesisResponse422 & {
  headers: Headers;
};

export type cancellableSynthesisResponse =
  | cancellableSynthesisResponseSuccess
  | cancellableSynthesisResponseError;

export const getCancellableSynthesisUrl = (params: CancellableSynthesisParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/cancellable_synthesis?${stringifiedParams}`
    : `/cancellable_synthesis`;
};

export const cancellableSynthesis = async (
  audioQuery: AudioQuery,
  params: CancellableSynthesisParams,
  options?: RequestInit
): Promise<cancellableSynthesisResponse> => {
  const res = await fetch(getCancellableSynthesisUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(audioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: cancellableSynthesisResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as cancellableSynthesisResponse;
};

/**
 * base64エンコードされたwavデータを一纏めにし、wavファイルで返します。
 * @summary base64エンコードされた複数のwavデータを一つに結合する
 */
export type connectWavesResponse200 = {
  data: Blob;
  status: 200;
};

export type connectWavesResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type connectWavesResponseSuccess = connectWavesResponse200 & {
  headers: Headers;
};
export type connectWavesResponseError = connectWavesResponse422 & {
  headers: Headers;
};

export type connectWavesResponse = connectWavesResponseSuccess | connectWavesResponseError;

export const getConnectWavesUrl = () => {
  return `/connect_waves`;
};

export const connectWaves = async (
  connectWavesBody: string[],
  options?: RequestInit
): Promise<connectWavesResponse> => {
  const res = await fetch(getConnectWavesUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(connectWavesBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: connectWavesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as connectWavesResponse;
};

/**
 * 利用可能なコアのバージョン一覧を取得します。
 * @summary Core Versions
 */
export type coreVersionsResponse200 = {
  data: string[];
  status: 200;
};

export type coreVersionsResponseSuccess = coreVersionsResponse200 & {
  headers: Headers;
};

export type coreVersionsResponse = coreVersionsResponseSuccess;

export const getCoreVersionsUrl = () => {
  return `/core_versions`;
};

export const coreVersions = async (options?: RequestInit): Promise<coreVersionsResponse> => {
  const res = await fetch(getCoreVersionsUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: coreVersionsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as coreVersionsResponse;
};

/**
 * 既存のプリセットを削除します。
 * @summary Delete Preset
 */
export type deletePresetResponse204 = {
  data: void;
  status: 204;
};

export type deletePresetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deletePresetResponseSuccess = deletePresetResponse204 & {
  headers: Headers;
};
export type deletePresetResponseError = deletePresetResponse422 & {
  headers: Headers;
};

export type deletePresetResponse = deletePresetResponseSuccess | deletePresetResponseError;

export const getDeletePresetUrl = (params: DeletePresetParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/delete_preset?${stringifiedParams}` : `/delete_preset`;
};

export const deletePreset = async (
  params: DeletePresetParams,
  options?: RequestInit
): Promise<deletePresetResponse> => {
  const res = await fetch(getDeletePresetUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deletePresetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as deletePresetResponse;
};

/**
 * ダウンロード可能な音声ライブラリの情報を返します。
 * @summary Downloadable Libraries
 */
export type downloadableLibrariesResponse200 = {
  data: DownloadableLibraryInfo[];
  status: 200;
};

export type downloadableLibrariesResponseSuccess = downloadableLibrariesResponse200 & {
  headers: Headers;
};

export type downloadableLibrariesResponse = downloadableLibrariesResponseSuccess;

export const getDownloadableLibrariesUrl = () => {
  return `/downloadable_libraries`;
};

export const downloadableLibraries = async (
  options?: RequestInit
): Promise<downloadableLibrariesResponse> => {
  const res = await fetch(getDownloadableLibrariesUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: downloadableLibrariesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as downloadableLibrariesResponse;
};

/**
 * エンジンマニフェストを取得します。
 * @summary Engine Manifest
 */
export type engineManifestResponse200 = {
  data: EngineManifest;
  status: 200;
};

export type engineManifestResponseSuccess = engineManifestResponse200 & {
  headers: Headers;
};

export type engineManifestResponse = engineManifestResponseSuccess;

export const getEngineManifestUrl = () => {
  return `/engine_manifest`;
};

export const engineManifest = async (options?: RequestInit): Promise<engineManifestResponse> => {
  const res = await fetch(getEngineManifestUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: engineManifestResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as engineManifestResponse;
};

/**
 * 歌唱音声合成を行います。
 * @summary Frame Synthesis
 */
export type frameSynthesisResponse200 = {
  data: Blob;
  status: 200;
};

export type frameSynthesisResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type frameSynthesisResponseSuccess = frameSynthesisResponse200 & {
  headers: Headers;
};
export type frameSynthesisResponseError = frameSynthesisResponse422 & {
  headers: Headers;
};

export type frameSynthesisResponse = frameSynthesisResponseSuccess | frameSynthesisResponseError;

export const getFrameSynthesisUrl = (params: FrameSynthesisParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/frame_synthesis?${stringifiedParams}`
    : `/frame_synthesis`;
};

export const frameSynthesis = async (
  frameAudioQuery: FrameAudioQuery,
  params: FrameSynthesisParams,
  options?: RequestInit
): Promise<frameSynthesisResponse> => {
  const res = await fetch(getFrameSynthesisUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(frameAudioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: frameSynthesisResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as frameSynthesisResponse;
};

/**
 * 他のユーザー辞書をインポートします。
 * @summary Import User Dict Words
 */
export type importUserDictWordsResponse204 = {
  data: void;
  status: 204;
};

export type importUserDictWordsResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type importUserDictWordsResponseSuccess = importUserDictWordsResponse204 & {
  headers: Headers;
};
export type importUserDictWordsResponseError = importUserDictWordsResponse422 & {
  headers: Headers;
};

export type importUserDictWordsResponse =
  | importUserDictWordsResponseSuccess
  | importUserDictWordsResponseError;

export const getImportUserDictWordsUrl = (params: ImportUserDictWordsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/import_user_dict?${stringifiedParams}`
    : `/import_user_dict`;
};

export const importUserDictWords = async (
  importUserDictWordsBody: ImportUserDictWordsBody,
  params: ImportUserDictWordsParams,
  options?: RequestInit
): Promise<importUserDictWordsResponse> => {
  const res = await fetch(getImportUserDictWordsUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(importUserDictWordsBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: importUserDictWordsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as importUserDictWordsResponse;
};

/**
 * 指定されたスタイルを初期化します。

実行しなくても他のAPIは使用できますが、初回実行時に時間がかかることがあります。
 * @summary Initialize Speaker
 */
export type initializeSpeakerResponse204 = {
  data: void;
  status: 204;
};

export type initializeSpeakerResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type initializeSpeakerResponseSuccess = initializeSpeakerResponse204 & {
  headers: Headers;
};
export type initializeSpeakerResponseError = initializeSpeakerResponse422 & {
  headers: Headers;
};

export type initializeSpeakerResponse =
  | initializeSpeakerResponseSuccess
  | initializeSpeakerResponseError;

export const getInitializeSpeakerUrl = (params: InitializeSpeakerParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/initialize_speaker?${stringifiedParams}`
    : `/initialize_speaker`;
};

export const initializeSpeaker = async (
  params: InitializeSpeakerParams,
  options?: RequestInit
): Promise<initializeSpeakerResponse> => {
  const res = await fetch(getInitializeSpeakerUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: initializeSpeakerResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as initializeSpeakerResponse;
};

/**
 * 音声ライブラリをインストールします。

音声ライブラリのZIPファイルをリクエストボディとして送信してください。
 * @summary Install Library
 */
export type installLibraryResponse204 = {
  data: void;
  status: 204;
};

export type installLibraryResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type installLibraryResponseSuccess = installLibraryResponse204 & {
  headers: Headers;
};
export type installLibraryResponseError = installLibraryResponse422 & {
  headers: Headers;
};

export type installLibraryResponse = installLibraryResponseSuccess | installLibraryResponseError;

export const getInstallLibraryUrl = (libraryUuid: string) => {
  return `/install_library/${libraryUuid}`;
};

export const installLibrary = async (
  libraryUuid: string,
  options?: RequestInit
): Promise<installLibraryResponse> => {
  const res = await fetch(getInstallLibraryUrl(libraryUuid), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: installLibraryResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as installLibraryResponse;
};

/**
 * インストールした音声ライブラリの情報を返します。
 * @summary Installed Libraries
 */
export type installedLibrariesResponse200 = {
  data: InstalledLibraries200;
  status: 200;
};

export type installedLibrariesResponseSuccess = installedLibrariesResponse200 & {
  headers: Headers;
};

export type installedLibrariesResponse = installedLibrariesResponseSuccess;

export const getInstalledLibrariesUrl = () => {
  return `/installed_libraries`;
};

export const installedLibraries = async (
  options?: RequestInit
): Promise<installedLibrariesResponse> => {
  const res = await fetch(getInstalledLibrariesUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: installedLibrariesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as installedLibrariesResponse;
};

/**
 * 指定されたスタイルが初期化されているかどうかを返します。
 * @summary Is Initialized Speaker
 */
export type isInitializedSpeakerResponse200 = {
  data: boolean;
  status: 200;
};

export type isInitializedSpeakerResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type isInitializedSpeakerResponseSuccess = isInitializedSpeakerResponse200 & {
  headers: Headers;
};
export type isInitializedSpeakerResponseError = isInitializedSpeakerResponse422 & {
  headers: Headers;
};

export type isInitializedSpeakerResponse =
  | isInitializedSpeakerResponseSuccess
  | isInitializedSpeakerResponseError;

export const getIsInitializedSpeakerUrl = (params: IsInitializedSpeakerParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/is_initialized_speaker?${stringifiedParams}`
    : `/is_initialized_speaker`;
};

export const isInitializedSpeaker = async (
  params: IsInitializedSpeakerParams,
  options?: RequestInit
): Promise<isInitializedSpeakerResponse> => {
  const res = await fetch(getIsInitializedSpeakerUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: isInitializedSpeakerResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as isInitializedSpeakerResponse;
};

/**
 * @summary アクセント句から音素の長さと音高を得る
 */
export type moraDataResponse200 = {
  data: AccentPhrase[];
  status: 200;
};

export type moraDataResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type moraDataResponseSuccess = moraDataResponse200 & {
  headers: Headers;
};
export type moraDataResponseError = moraDataResponse422 & {
  headers: Headers;
};

export type moraDataResponse = moraDataResponseSuccess | moraDataResponseError;

export const getMoraDataUrl = (params: MoraDataParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/mora_data?${stringifiedParams}` : `/mora_data`;
};

export const moraData = async (
  accentPhrase: AccentPhrase[],
  params: MoraDataParams,
  options?: RequestInit
): Promise<moraDataResponse> => {
  const res = await fetch(getMoraDataUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(accentPhrase),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: moraDataResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as moraDataResponse;
};

/**
 * @summary アクセント句から音素の長さを得る
 */
export type moraLengthResponse200 = {
  data: AccentPhrase[];
  status: 200;
};

export type moraLengthResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type moraLengthResponseSuccess = moraLengthResponse200 & {
  headers: Headers;
};
export type moraLengthResponseError = moraLengthResponse422 & {
  headers: Headers;
};

export type moraLengthResponse = moraLengthResponseSuccess | moraLengthResponseError;

export const getMoraLengthUrl = (params: MoraLengthParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/mora_length?${stringifiedParams}` : `/mora_length`;
};

export const moraLength = async (
  accentPhrase: AccentPhrase[],
  params: MoraLengthParams,
  options?: RequestInit
): Promise<moraLengthResponse> => {
  const res = await fetch(getMoraLengthUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(accentPhrase),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: moraLengthResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as moraLengthResponse;
};

/**
 * @summary アクセント句から音高を得る
 */
export type moraPitchResponse200 = {
  data: AccentPhrase[];
  status: 200;
};

export type moraPitchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type moraPitchResponseSuccess = moraPitchResponse200 & {
  headers: Headers;
};
export type moraPitchResponseError = moraPitchResponse422 & {
  headers: Headers;
};

export type moraPitchResponse = moraPitchResponseSuccess | moraPitchResponseError;

export const getMoraPitchUrl = (params: MoraPitchParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/mora_pitch?${stringifiedParams}` : `/mora_pitch`;
};

export const moraPitch = async (
  accentPhrase: AccentPhrase[],
  params: MoraPitchParams,
  options?: RequestInit
): Promise<moraPitchResponse> => {
  const res = await fetch(getMoraPitchUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(accentPhrase),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: moraPitchResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as moraPitchResponse;
};

/**
 * 指定されたベーススタイルに対してエンジン内の各キャラクターがモーフィング機能を利用可能か返します。

モーフィングの許可/禁止は`/speakers`の`speaker.supported_features.synthesis_morphing`に記載されています。
プロパティが存在しない場合は、モーフィングが許可されているとみなします。
返り値のスタイルIDはstring型なので注意。
 * @summary 指定したスタイルに対してエンジン内のキャラクターがモーフィングが可能か判定する
 */
export type morphableTargetsResponse200 = {
  data: MorphableTargets200Item[];
  status: 200;
};

export type morphableTargetsResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type morphableTargetsResponseSuccess = morphableTargetsResponse200 & {
  headers: Headers;
};
export type morphableTargetsResponseError = morphableTargetsResponse422 & {
  headers: Headers;
};

export type morphableTargetsResponse =
  | morphableTargetsResponseSuccess
  | morphableTargetsResponseError;

export const getMorphableTargetsUrl = (params?: MorphableTargetsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/morphable_targets?${stringifiedParams}`
    : `/morphable_targets`;
};

export const morphableTargets = async (
  morphableTargetsBody: number[],
  params?: MorphableTargetsParams,
  options?: RequestInit
): Promise<morphableTargetsResponse> => {
  const res = await fetch(getMorphableTargetsUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(morphableTargetsBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: morphableTargetsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as morphableTargetsResponse;
};

/**
 * @summary 複数まとめて音声合成する
 */
export type multiSynthesisResponse200 = {
  data: Blob;
  status: 200;
};

export type multiSynthesisResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type multiSynthesisResponseSuccess = multiSynthesisResponse200 & {
  headers: Headers;
};
export type multiSynthesisResponseError = multiSynthesisResponse422 & {
  headers: Headers;
};

export type multiSynthesisResponse = multiSynthesisResponseSuccess | multiSynthesisResponseError;

export const getMultiSynthesisUrl = (params: MultiSynthesisParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/multi_synthesis?${stringifiedParams}`
    : `/multi_synthesis`;
};

export const multiSynthesis = async (
  audioQuery: AudioQuery[],
  params: MultiSynthesisParams,
  options?: RequestInit
): Promise<multiSynthesisResponse> => {
  const res = await fetch(getMultiSynthesisUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(audioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: multiSynthesisResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as multiSynthesisResponse;
};

/**
 * エンジンが保持しているプリセットの設定を返します。
 * @summary Get Presets
 */
export type getPresetsResponse200 = {
  data: Preset[];
  status: 200;
};

export type getPresetsResponseSuccess = getPresetsResponse200 & {
  headers: Headers;
};

export type getPresetsResponse = getPresetsResponseSuccess;

export const getGetPresetsUrl = () => {
  return `/presets`;
};

export const getPresets = async (options?: RequestInit): Promise<getPresetsResponse> => {
  const res = await fetch(getGetPresetsUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getPresetsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getPresetsResponse;
};

/**
 * 設定ページを返します。
 * @summary Setting Get
 */
export type settingGetResponse200 = {
  data: void;
  status: 200;
};

export type settingGetResponseSuccess = settingGetResponse200 & {
  headers: Headers;
};

export type settingGetResponse = settingGetResponseSuccess;

export const getSettingGetUrl = () => {
  return `/setting`;
};

export const settingGet = async (options?: RequestInit): Promise<settingGetResponse> => {
  const res = await fetch(getSettingGetUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: settingGetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as settingGetResponse;
};

/**
 * 設定を更新します。
 * @summary Setting Post
 */
export type settingPostResponse204 = {
  data: void;
  status: 204;
};

export type settingPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type settingPostResponseSuccess = settingPostResponse204 & {
  headers: Headers;
};
export type settingPostResponseError = settingPostResponse422 & {
  headers: Headers;
};

export type settingPostResponse = settingPostResponseSuccess | settingPostResponseError;

export const getSettingPostUrl = () => {
  return `/setting`;
};

export const settingPost = async (
  bodySettingPostSettingPost: BodySettingPostSettingPost,
  options?: RequestInit
): Promise<settingPostResponse> => {
  const formUrlEncoded = new URLSearchParams();
  if (bodySettingPostSettingPost.allow_origin !== undefined) {
    formUrlEncoded.append(`allow_origin`, bodySettingPostSettingPost.allow_origin);
  }
  formUrlEncoded.append(`cors_policy_mode`, bodySettingPostSettingPost.cors_policy_mode);

  const res = await fetch(getSettingPostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: formUrlEncoded,
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: settingPostResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as settingPostResponse;
};

/**
 * 歌唱音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま歌唱音声合成に利用できます。各値の意味は`Schemas`を参照してください。
 * @summary 歌唱音声合成用のクエリを作成する
 */
export type singFrameAudioQueryResponse200 = {
  data: FrameAudioQuery;
  status: 200;
};

export type singFrameAudioQueryResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singFrameAudioQueryResponseSuccess = singFrameAudioQueryResponse200 & {
  headers: Headers;
};
export type singFrameAudioQueryResponseError = singFrameAudioQueryResponse422 & {
  headers: Headers;
};

export type singFrameAudioQueryResponse =
  | singFrameAudioQueryResponseSuccess
  | singFrameAudioQueryResponseError;

export const getSingFrameAudioQueryUrl = (params: SingFrameAudioQueryParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/sing_frame_audio_query?${stringifiedParams}`
    : `/sing_frame_audio_query`;
};

export const singFrameAudioQuery = async (
  score: Score,
  params: SingFrameAudioQueryParams,
  options?: RequestInit
): Promise<singFrameAudioQueryResponse> => {
  const res = await fetch(getSingFrameAudioQueryUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(score),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singFrameAudioQueryResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singFrameAudioQueryResponse;
};

/**
 * @summary 楽譜・歌唱音声合成用のクエリからフレームごとの基本周波数を得る
 */
export type singFrameF0Response200 = {
  data: number[];
  status: 200;
};

export type singFrameF0Response422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singFrameF0ResponseSuccess = singFrameF0Response200 & {
  headers: Headers;
};
export type singFrameF0ResponseError = singFrameF0Response422 & {
  headers: Headers;
};

export type singFrameF0Response = singFrameF0ResponseSuccess | singFrameF0ResponseError;

export const getSingFrameF0Url = (params: SingFrameF0Params) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/sing_frame_f0?${stringifiedParams}` : `/sing_frame_f0`;
};

export const singFrameF0 = async (
  bodySingFrameF0SingFrameF0Post: BodySingFrameF0SingFrameF0Post,
  params: SingFrameF0Params,
  options?: RequestInit
): Promise<singFrameF0Response> => {
  const res = await fetch(getSingFrameF0Url(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(bodySingFrameF0SingFrameF0Post),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singFrameF0Response['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singFrameF0Response;
};

/**
 * @summary 楽譜・歌唱音声合成用のクエリからフレームごとの音量を得る
 */
export type singFrameVolumeResponse200 = {
  data: number[];
  status: 200;
};

export type singFrameVolumeResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singFrameVolumeResponseSuccess = singFrameVolumeResponse200 & {
  headers: Headers;
};
export type singFrameVolumeResponseError = singFrameVolumeResponse422 & {
  headers: Headers;
};

export type singFrameVolumeResponse = singFrameVolumeResponseSuccess | singFrameVolumeResponseError;

export const getSingFrameVolumeUrl = (params: SingFrameVolumeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/sing_frame_volume?${stringifiedParams}`
    : `/sing_frame_volume`;
};

export const singFrameVolume = async (
  bodySingFrameVolumeSingFrameVolumePost: BodySingFrameVolumeSingFrameVolumePost,
  params: SingFrameVolumeParams,
  options?: RequestInit
): Promise<singFrameVolumeResponse> => {
  const res = await fetch(getSingFrameVolumeUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(bodySingFrameVolumeSingFrameVolumePost),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singFrameVolumeResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singFrameVolumeResponse;
};

/**
 * UUID で指定された歌えるキャラクターの情報を返します。

画像や音声はresource_formatで指定した形式で返されます。
 * @summary Singer Info
 */
export type singerInfoResponse200 = {
  data: SpeakerInfo;
  status: 200;
};

export type singerInfoResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singerInfoResponseSuccess = singerInfoResponse200 & {
  headers: Headers;
};
export type singerInfoResponseError = singerInfoResponse422 & {
  headers: Headers;
};

export type singerInfoResponse = singerInfoResponseSuccess | singerInfoResponseError;

export const getSingerInfoUrl = (params: SingerInfoParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/singer_info?${stringifiedParams}` : `/singer_info`;
};

export const singerInfo = async (
  params: SingerInfoParams,
  options?: RequestInit
): Promise<singerInfoResponse> => {
  const res = await fetch(getSingerInfoUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singerInfoResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singerInfoResponse;
};

/**
 * 歌えるキャラクターの情報の一覧を返します。
 * @summary Singers
 */
export type singersResponse200 = {
  data: Speaker[];
  status: 200;
};

export type singersResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singersResponseSuccess = singersResponse200 & {
  headers: Headers;
};
export type singersResponseError = singersResponse422 & {
  headers: Headers;
};

export type singersResponse = singersResponseSuccess | singersResponseError;

export const getSingersUrl = (params?: SingersParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/singers?${stringifiedParams}` : `/singers`;
};

export const singers = async (
  params?: SingersParams,
  options?: RequestInit
): Promise<singersResponse> => {
  const res = await fetch(getSingersUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singersResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singersResponse;
};

/**
 * UUID で指定された喋れるキャラクターの情報を返します。

画像や音声はresource_formatで指定した形式で返されます。
 * @summary Speaker Info
 */
export type speakerInfoResponse200 = {
  data: SpeakerInfo;
  status: 200;
};

export type speakerInfoResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type speakerInfoResponseSuccess = speakerInfoResponse200 & {
  headers: Headers;
};
export type speakerInfoResponseError = speakerInfoResponse422 & {
  headers: Headers;
};

export type speakerInfoResponse = speakerInfoResponseSuccess | speakerInfoResponseError;

export const getSpeakerInfoUrl = (params: SpeakerInfoParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/speaker_info?${stringifiedParams}` : `/speaker_info`;
};

export const speakerInfo = async (
  params: SpeakerInfoParams,
  options?: RequestInit
): Promise<speakerInfoResponse> => {
  const res = await fetch(getSpeakerInfoUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: speakerInfoResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as speakerInfoResponse;
};

/**
 * 喋れるキャラクターの情報の一覧を返します。
 * @summary Speakers
 */
export type speakersResponse200 = {
  data: Speaker[];
  status: 200;
};

export type speakersResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type speakersResponseSuccess = speakersResponse200 & {
  headers: Headers;
};
export type speakersResponseError = speakersResponse422 & {
  headers: Headers;
};

export type speakersResponse = speakersResponseSuccess | speakersResponseError;

export const getSpeakersUrl = (params?: SpeakersParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/speakers?${stringifiedParams}` : `/speakers`;
};

export const speakers = async (
  params?: SpeakersParams,
  options?: RequestInit
): Promise<speakersResponse> => {
  const res = await fetch(getSpeakersUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: speakersResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as speakersResponse;
};

/**
 * 対応デバイスの一覧を取得します。
 * @summary Supported Devices
 */
export type supportedDevicesResponse200 = {
  data: SupportedDevicesInfo;
  status: 200;
};

export type supportedDevicesResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type supportedDevicesResponseSuccess = supportedDevicesResponse200 & {
  headers: Headers;
};
export type supportedDevicesResponseError = supportedDevicesResponse422 & {
  headers: Headers;
};

export type supportedDevicesResponse =
  | supportedDevicesResponseSuccess
  | supportedDevicesResponseError;

export const getSupportedDevicesUrl = (params?: SupportedDevicesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/supported_devices?${stringifiedParams}`
    : `/supported_devices`;
};

export const supportedDevices = async (
  params?: SupportedDevicesParams,
  options?: RequestInit
): Promise<supportedDevicesResponse> => {
  const res = await fetch(getSupportedDevicesUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: supportedDevicesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as supportedDevicesResponse;
};

/**
 * @summary 音声合成する
 */
export type synthesisResponse200 = {
  data: Blob;
  status: 200;
};

export type synthesisResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type synthesisResponseSuccess = synthesisResponse200 & {
  headers: Headers;
};
export type synthesisResponseError = synthesisResponse422 & {
  headers: Headers;
};

export type synthesisResponse = synthesisResponseSuccess | synthesisResponseError;

export const getSynthesisUrl = (params: SynthesisParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/synthesis?${stringifiedParams}` : `/synthesis`;
};

export const synthesis = async (
  audioQuery: AudioQuery,
  params: SynthesisParams,
  options?: RequestInit
): Promise<synthesisResponse> => {
  const res = await fetch(getSynthesisUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(audioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: synthesisResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as synthesisResponse;
};

/**
 * 指定された2種類のスタイルで音声を合成、指定した割合でモーフィングした音声を得ます。

モーフィングの割合は`morph_rate`で指定でき、0.0でベースのスタイル、1.0でターゲットのスタイルに近づきます。
 * @summary 2種類のスタイルでモーフィングした音声を合成する
 */
export type synthesisMorphingResponse200 = {
  data: Blob;
  status: 200;
};

export type synthesisMorphingResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type synthesisMorphingResponseSuccess = synthesisMorphingResponse200 & {
  headers: Headers;
};
export type synthesisMorphingResponseError = synthesisMorphingResponse422 & {
  headers: Headers;
};

export type synthesisMorphingResponse =
  | synthesisMorphingResponseSuccess
  | synthesisMorphingResponseError;

export const getSynthesisMorphingUrl = (params: SynthesisMorphingParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/synthesis_morphing?${stringifiedParams}`
    : `/synthesis_morphing`;
};

export const synthesisMorphing = async (
  audioQuery: AudioQuery,
  params: SynthesisMorphingParams,
  options?: RequestInit
): Promise<synthesisMorphingResponse> => {
  const res = await fetch(getSynthesisMorphingUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(audioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: synthesisMorphingResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as synthesisMorphingResponse;
};

/**
 * 音声ライブラリをアンインストールします。
 * @summary Uninstall Library
 */
export type uninstallLibraryResponse204 = {
  data: void;
  status: 204;
};

export type uninstallLibraryResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type uninstallLibraryResponseSuccess = uninstallLibraryResponse204 & {
  headers: Headers;
};
export type uninstallLibraryResponseError = uninstallLibraryResponse422 & {
  headers: Headers;
};

export type uninstallLibraryResponse =
  | uninstallLibraryResponseSuccess
  | uninstallLibraryResponseError;

export const getUninstallLibraryUrl = (libraryUuid: string) => {
  return `/uninstall_library/${libraryUuid}`;
};

export const uninstallLibrary = async (
  libraryUuid: string,
  options?: RequestInit
): Promise<uninstallLibraryResponse> => {
  const res = await fetch(getUninstallLibraryUrl(libraryUuid), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: uninstallLibraryResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as uninstallLibraryResponse;
};

/**
 * 既存のプリセットを更新します。
 * @summary Update Preset
 */
export type updatePresetResponse200 = {
  data: number;
  status: 200;
};

export type updatePresetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updatePresetResponseSuccess = updatePresetResponse200 & {
  headers: Headers;
};
export type updatePresetResponseError = updatePresetResponse422 & {
  headers: Headers;
};

export type updatePresetResponse = updatePresetResponseSuccess | updatePresetResponseError;

export const getUpdatePresetUrl = () => {
  return `/update_preset`;
};

export const updatePreset = async (
  preset: Preset,
  options?: RequestInit
): Promise<updatePresetResponse> => {
  const res = await fetch(getUpdatePresetUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(preset),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updatePresetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as updatePresetResponse;
};

/**
 * ユーザー辞書に登録されている単語の一覧を返します。

単語の表層形(surface)は正規化済みの物を返します。
 * @summary Get User Dict Words
 */
export type getUserDictWordsResponse200 = {
  data: GetUserDictWords200;
  status: 200;
};

export type getUserDictWordsResponseSuccess = getUserDictWordsResponse200 & {
  headers: Headers;
};

export type getUserDictWordsResponse = getUserDictWordsResponseSuccess;

export const getGetUserDictWordsUrl = () => {
  return `/user_dict`;
};

export const getUserDictWords = async (
  options?: RequestInit
): Promise<getUserDictWordsResponse> => {
  const res = await fetch(getGetUserDictWordsUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getUserDictWordsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getUserDictWordsResponse;
};

/**
 * ユーザー辞書に言葉を追加します。
 * @summary Add User Dict Word
 */
export type addUserDictWordResponse200 = {
  data: string;
  status: 200;
};

export type addUserDictWordResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type addUserDictWordResponseSuccess = addUserDictWordResponse200 & {
  headers: Headers;
};
export type addUserDictWordResponseError = addUserDictWordResponse422 & {
  headers: Headers;
};

export type addUserDictWordResponse = addUserDictWordResponseSuccess | addUserDictWordResponseError;

export const getAddUserDictWordUrl = (params: AddUserDictWordParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/user_dict_word?${stringifiedParams}` : `/user_dict_word`;
};

export const addUserDictWord = async (
  params: AddUserDictWordParams,
  options?: RequestInit
): Promise<addUserDictWordResponse> => {
  const res = await fetch(getAddUserDictWordUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: addUserDictWordResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as addUserDictWordResponse;
};

/**
 * ユーザー辞書に登録されている言葉を削除します。
 * @summary Delete User Dict Word
 */
export type deleteUserDictWordResponse204 = {
  data: void;
  status: 204;
};

export type deleteUserDictWordResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deleteUserDictWordResponseSuccess = deleteUserDictWordResponse204 & {
  headers: Headers;
};
export type deleteUserDictWordResponseError = deleteUserDictWordResponse422 & {
  headers: Headers;
};

export type deleteUserDictWordResponse =
  | deleteUserDictWordResponseSuccess
  | deleteUserDictWordResponseError;

export const getDeleteUserDictWordUrl = (wordUuid: string) => {
  return `/user_dict_word/${wordUuid}`;
};

export const deleteUserDictWord = async (
  wordUuid: string,
  options?: RequestInit
): Promise<deleteUserDictWordResponse> => {
  const res = await fetch(getDeleteUserDictWordUrl(wordUuid), {
    ...options,
    method: 'DELETE',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteUserDictWordResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as deleteUserDictWordResponse;
};

/**
 * ユーザー辞書に登録されている言葉を更新します。
 * @summary Rewrite User Dict Word
 */
export type rewriteUserDictWordResponse204 = {
  data: void;
  status: 204;
};

export type rewriteUserDictWordResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type rewriteUserDictWordResponseSuccess = rewriteUserDictWordResponse204 & {
  headers: Headers;
};
export type rewriteUserDictWordResponseError = rewriteUserDictWordResponse422 & {
  headers: Headers;
};

export type rewriteUserDictWordResponse =
  | rewriteUserDictWordResponseSuccess
  | rewriteUserDictWordResponseError;

export const getRewriteUserDictWordUrl = (wordUuid: string, params: RewriteUserDictWordParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user_dict_word/${wordUuid}?${stringifiedParams}`
    : `/user_dict_word/${wordUuid}`;
};

export const rewriteUserDictWord = async (
  wordUuid: string,
  params: RewriteUserDictWordParams,
  options?: RequestInit
): Promise<rewriteUserDictWordResponse> => {
  const res = await fetch(getRewriteUserDictWordUrl(wordUuid, params), {
    ...options,
    method: 'PUT',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: rewriteUserDictWordResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as rewriteUserDictWordResponse;
};

/**
 * テキストがAquesTalk 風記法に従っているかどうかを判定します。

従っていない場合はエラーが返ります。
 * @summary テキストがAquesTalk 風記法に従っているか判定する
 */
export type validateKanaResponse200 = {
  data: boolean;
  status: 200;
};

export type validateKanaResponse400 = {
  data: ParseKanaBadRequest;
  status: 400;
};

export type validateKanaResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type validateKanaResponseSuccess = validateKanaResponse200 & {
  headers: Headers;
};
export type validateKanaResponseError = (validateKanaResponse400 | validateKanaResponse422) & {
  headers: Headers;
};

export type validateKanaResponse = validateKanaResponseSuccess | validateKanaResponseError;

export const getValidateKanaUrl = (params: ValidateKanaParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/validate_kana?${stringifiedParams}` : `/validate_kana`;
};

export const validateKana = async (
  params: ValidateKanaParams,
  options?: RequestInit
): Promise<validateKanaResponse> => {
  const res = await fetch(getValidateKanaUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: validateKanaResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as validateKanaResponse;
};

/**
 * エンジンのバージョンを取得します。
 * @summary Version
 */
export type versionResponse200 = {
  data: string;
  status: 200;
};

export type versionResponseSuccess = versionResponse200 & {
  headers: Headers;
};

export type versionResponse = versionResponseSuccess;

export const getVersionUrl = () => {
  return `/version`;
};

export const version = async (options?: RequestInit): Promise<versionResponse> => {
  const res = await fetch(getVersionUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: versionResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as versionResponse;
};
