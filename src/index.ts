/**
 * Generated by orval v7.12.2 ğŸº
 * Do not edit manually.
 * VOICEVOX ENGINE OSS
 * VOICEVOX OSS ã®éŸ³å£°åˆæˆã‚¨ãƒ³ã‚¸ãƒ³ã§ã™ã€‚
 * OpenAPI spec version: latest
 */
/**
 * ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã”ã¨ã®æƒ…å ±ã€‚
 */
export interface AccentPhrase {
  /** ã‚¢ã‚¯ã‚»ãƒ³ãƒˆç®‡æ‰€ */
  accent: number;
  /** ç–‘å•ç³»ã‹ã©ã†ã‹ */
  is_interrogative?: boolean;
  /** ãƒ¢ãƒ¼ãƒ©ã®ãƒªã‚¹ãƒˆ */
  moras: Mora[];
  /** ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã®æœ«å°¾ã«ã¤ãç„¡éŸ³ãƒ¢ãƒ¼ãƒ©ã€‚null ã®å ´åˆã¯ç„¡éŸ³ãƒ¢ãƒ¼ãƒ©ã‚’ä»˜ã‘ãªã„ã€‚ */
  pause_mora?: Mora;
}

/**
 * å¥èª­ç‚¹ãªã©ã®ç„¡éŸ³æ™‚é–“ã€‚nullã®ã¨ãã¯ç„¡è¦–ã•ã‚Œã‚‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯null
 */
export type AudioQueryPauseLength = number | null;

/**
 * éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã€‚
 */
export interface AudioQuery {
  /** ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã®ãƒªã‚¹ãƒˆ */
  accent_phrases: AccentPhrase[];
  /** å…¨ä½“ã®æŠ‘æš */
  intonationScale: number;
  /** [èª­ã¿å–ã‚Šå°‚ç”¨]AquesTalk é¢¨è¨˜æ³•ã«ã‚ˆã‚‹ãƒ†ã‚­ã‚¹ãƒˆã€‚éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã¨ã—ã¦ã¯ç„¡è¦–ã•ã‚Œã‚‹ */
  kana?: string;
  /** éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®å‡ºåŠ›ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ */
  outputSamplingRate: number;
  /** éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¹ãƒ†ãƒ¬ã‚ªå‡ºåŠ›ã™ã‚‹ã‹å¦ã‹ */
  outputStereo: boolean;
  /** å¥èª­ç‚¹ãªã©ã®ç„¡éŸ³æ™‚é–“ã€‚nullã®ã¨ãã¯ç„¡è¦–ã•ã‚Œã‚‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯null */
  pauseLength?: AudioQueryPauseLength;
  /** å¥èª­ç‚¹ãªã©ã®ç„¡éŸ³æ™‚é–“ï¼ˆå€ç‡ï¼‰ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯1 */
  pauseLengthScale?: number;
  /** å…¨ä½“ã®éŸ³é«˜ */
  pitchScale: number;
  /** éŸ³å£°ã®å¾Œã®ç„¡éŸ³æ™‚é–“ */
  postPhonemeLength: number;
  /** éŸ³å£°ã®å‰ã®ç„¡éŸ³æ™‚é–“ */
  prePhonemeLength: number;
  /** å…¨ä½“ã®è©±é€Ÿ */
  speedScale: number;
  /** å…¨ä½“ã®éŸ³é‡ */
  volumeScale: number;
}

/**
 * éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±ã€‚
 */
export interface BaseLibraryInfo {
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒã‚¤ãƒˆæ•° */
  bytes: number;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰URL */
  download_url: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åå‰ */
  name: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å«ã¾ã‚Œã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒªã‚¹ãƒˆ */
  speakers: LibrarySpeaker[];
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®UUID */
  uuid: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  version: string;
}

export interface BodySettingPostSettingPost {
  allow_origin?: string;
  cors_policy_mode: CorsPolicyMode;
}

export interface BodySingFrameF0SingFrameF0Post {
  frame_audio_query: FrameAudioQuery;
  score: Score;
}

export interface BodySingFrameVolumeSingFrameVolumePost {
  frame_audio_query: FrameAudioQuery;
  score: Score;
}

/**
 * CORSã®è¨±å¯ãƒ¢ãƒ¼ãƒ‰ã€‚
 */
export type CorsPolicyMode = (typeof CorsPolicyMode)[keyof typeof CorsPolicyMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CorsPolicyMode = {
  all: 'all',
  localapps: 'localapps',
} as const;

/**
 * ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªéŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±ã€‚
 */
export interface DownloadableLibraryInfo {
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒã‚¤ãƒˆæ•° */
  bytes: number;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰URL */
  download_url: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åå‰ */
  name: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å«ã¾ã‚Œã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒªã‚¹ãƒˆ */
  speakers: LibrarySpeaker[];
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®UUID */
  uuid: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  version: string;
}

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³è‡ªä½“ã«é–¢ã™ã‚‹æƒ…å ±ã€‚
 */
export interface EngineManifest {
  /** ãƒ–ãƒ©ãƒ³ãƒ‰å */
  brand_name: string;
  /** ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å‘¨æ³¢æ•° */
  default_sampling_rate: number;
  /** ä¾å­˜é–¢ä¿‚ã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ± */
  dependency_licenses: LicenseInfo[];
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ */
  frame_rate: number;
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’BASE64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã‚‚ã® */
  icon: string;
  /** ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  manifest_version: string;
  /** ã‚¨ãƒ³ã‚¸ãƒ³å */
  name: string;
  /** ã‚¨ãƒ³ã‚¸ãƒ³ãŒæŒã¤æ©Ÿèƒ½ */
  supported_features: SupportedFeatures;
  /** ã‚¨ãƒ³ã‚¸ãƒ³ãŒå¯¾å¿œã™ã‚‹vvlibã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  supported_vvlib_manifest_version?: string;
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆ©ç”¨è¦ç´„ */
  terms_of_service: string;
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆæƒ…å ± */
  update_infos: UpdateInfo[];
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®URL */
  url: string;
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®UUID */
  uuid: string;
}

/**
 * ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã€‚
 */
export interface FrameAudioQuery {
  /** ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®åŸºæœ¬å‘¨æ³¢æ•° */
  f0: number[];
  /** éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®å‡ºåŠ›ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ */
  outputSamplingRate: number;
  /** éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¹ãƒ†ãƒ¬ã‚ªå‡ºåŠ›ã™ã‚‹ã‹å¦ã‹ */
  outputStereo: boolean;
  /** éŸ³ç´ ã®ãƒªã‚¹ãƒˆ */
  phonemes: FramePhoneme[];
  /** ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®éŸ³é‡ */
  volume: number[];
  /** å…¨ä½“ã®éŸ³é‡ */
  volumeScale: number;
}

/**
 * éŸ³ç¬¦ã®ID
 */
export type FramePhonemeNoteId = string | null;

/**
 * éŸ³ç´ ã®æƒ…å ±ã€‚
 */
export interface FramePhoneme {
  /** éŸ³ç´ ã®ãƒ•ãƒ¬ãƒ¼ãƒ é•· */
  frame_length: number;
  /** éŸ³ç¬¦ã®ID */
  note_id?: FramePhonemeNoteId;
  /** éŸ³ç´  */
  phoneme: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±ã€‚
 */
export interface InstalledLibraryInfo {
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒã‚¤ãƒˆæ•° */
  bytes: number;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰URL */
  download_url: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åå‰ */
  name: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å«ã¾ã‚Œã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒªã‚¹ãƒˆ */
  speakers: LibrarySpeaker[];
  /** ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¯èƒ½ã‹ã©ã†ã‹ */
  uninstallable: boolean;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®UUID */
  uuid: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  version: string;
}

/**
 * éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å«ã¾ã‚Œã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æƒ…å ±ã€‚
 */
export interface LibrarySpeaker {
  speaker: Speaker;
  speaker_info: SpeakerInfo;
}

/**
 * ä¾å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±ã€‚
 */
export interface LicenseInfo {
  /** ä¾å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹å */
  license?: string;
  /** ä¾å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå */
  name: string;
  /** ä¾å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æœ¬æ–‡ */
  text: string;
  /** ä¾å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  version?: string;
}

/**
 * ãƒ¢ãƒ¼ãƒ©ï¼ˆå­éŸ³ï¼‹æ¯éŸ³ï¼‰ã”ã¨ã®æƒ…å ±ã€‚
 */
export interface Mora {
  /** å­éŸ³ã®éŸ³ç´  */
  consonant?: string;
  /** å­éŸ³ã®é•·ã• */
  consonant_length?: number;
  /** éŸ³é«˜ */
  pitch: number;
  /** æ–‡å­— */
  text: string;
  /** æ¯éŸ³ã®éŸ³ç´  */
  vowel: string;
  /** æ¯éŸ³ã®é•·ã• */
  vowel_length: number;
}

/**
 * ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ç›¸æ‰‹ã¨ã—ã¦ã®æƒ…å ±ã€‚
 */
export interface MorphableTargetInfo {
  /** æŒ‡å®šã—ãŸã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«å¯¾ã—ã¦ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã®å¯å¦ */
  is_morphable: boolean;
}

/**
 * ID
 */
export type NoteId = string | null;

/**
 * éŸ³ç¬¦ã”ã¨ã®æƒ…å ±ã€‚
 */
export interface Note {
  /** éŸ³ç¬¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ é•· */
  frame_length: number;
  /** ID */
  id?: NoteId;
  /** éŸ³éš */
  key?: number;
  /** éŸ³ç¬¦ã®æ­Œè© */
  lyric: string;
}

/**
 * ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã—ãŸç®‡æ‰€
 */
export type ParseKanaBadRequestErrorArgs = { [key: string]: string };

/**
 * èª­ã¿ä»®åã®ãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ãŸã€‚
 */
export interface ParseKanaBadRequest {
  /** ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã—ãŸç®‡æ‰€ */
  error_args: ParseKanaBadRequestErrorArgs;
  /** ã‚¨ãƒ©ãƒ¼å

|name|description|
|---|---|
| UNKNOWN_TEXT | åˆ¤åˆ¥ã§ããªã„èª­ã¿ä»®åãŒã‚ã‚Šã¾ã™: {text} |
| ACCENT_TOP | å¥é ­ã«ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã¯ç½®ã‘ã¾ã›ã‚“: {text} |
| ACCENT_TWICE | 1ã¤ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã«äºŒã¤ä»¥ä¸Šã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã¯ç½®ã‘ã¾ã›ã‚“: {text} |
| ACCENT_NOTFOUND | ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’æŒ‡å®šã—ã¦ã„ãªã„ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ãŒã‚ã‚Šã¾ã™: {text} |
| EMPTY_PHRASE | {position}ç•ªç›®ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ãŒç©ºç™½ã§ã™ |
| INTERROGATION_MARK_NOT_AT_END | ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥æœ«ä»¥å¤–ã«ã€Œï¼Ÿã€ã¯ç½®ã‘ã¾ã›ã‚“: {text} |
| INFINITE_LOOP | å‡¦ç†æ™‚ã«ç„¡é™ãƒ«ãƒ¼ãƒ—ã«ãªã£ã¦ã—ã¾ã„ã¾ã—ãŸ...ãƒã‚°å ±å‘Šã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚ | */
  error_name: string;
  /** ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  text: string;
}

/**
 * ãƒ—ãƒªã‚»ãƒƒãƒˆæƒ…å ±ã€‚
 */
export interface Preset {
  /** ãƒ—ãƒªã‚»ãƒƒãƒˆID */
  id: number;
  /** å…¨ä½“ã®æŠ‘æš */
  intonationScale: number;
  /** ãƒ—ãƒªã‚»ãƒƒãƒˆå */
  name: string;
  /** å¥èª­ç‚¹ãªã©ã®ç„¡éŸ³æ™‚é–“ */
  pauseLength?: number;
  /** å¥èª­ç‚¹ãªã©ã®ç„¡éŸ³æ™‚é–“ï¼ˆå€ç‡ï¼‰ */
  pauseLengthScale?: number;
  /** å…¨ä½“ã®éŸ³é«˜ */
  pitchScale: number;
  /** éŸ³å£°ã®å¾Œã®ç„¡éŸ³æ™‚é–“ */
  postPhonemeLength: number;
  /** éŸ³å£°ã®å‰ã®ç„¡éŸ³æ™‚é–“ */
  prePhonemeLength: number;
  /** ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®UUID */
  speaker_uuid: string;
  /** å…¨ä½“ã®è©±é€Ÿ */
  speedScale: number;
  /** ã‚¹ã‚¿ã‚¤ãƒ«ID */
  style_id: number;
  /** å…¨ä½“ã®éŸ³é‡ */
  volumeScale: number;
}

/**
 * æ¥½è­œæƒ…å ±ã€‚
 */
export interface Score {
  /** éŸ³ç¬¦ã®ãƒªã‚¹ãƒˆ */
  notes: Note[];
}

/**
 * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±
 */
export interface Speaker {
  /** åå‰ */
  name: string;
  /** ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®UUID */
  speaker_uuid: string;
  /** ã‚¹ã‚¿ã‚¤ãƒ«ã®ä¸€è¦§ */
  styles: SpeakerStyle[];
  /** ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¯¾å¿œæ©Ÿèƒ½ */
  supported_features?: SpeakerSupportedFeatures;
  /** ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  version: string;
}

/**
 * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®è¿½åŠ æƒ…å ±
 */
export interface SpeakerInfo {
  /** policy.md */
  policy: string;
  /** ç«‹ã¡çµµç”»åƒã‚’base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã‚‚ã®ã€ã‚ã‚‹ã„ã¯URL */
  portrait: string;
  /** ã‚¹ã‚¿ã‚¤ãƒ«ã®è¿½åŠ æƒ…å ± */
  style_infos: StyleInfo[];
}

/**
 * ã‚¹ã‚¿ã‚¤ãƒ«ã®ç¨®é¡ã€‚talk:éŸ³å£°åˆæˆã‚¯ã‚¨ãƒªã®ä½œæˆã¨éŸ³å£°åˆæˆãŒå¯èƒ½ã€‚singing_teacher:æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®ä½œæˆãŒå¯èƒ½ã€‚frame_decode:æ­Œå”±éŸ³å£°åˆæˆãŒå¯èƒ½ã€‚sing:æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®ä½œæˆã¨æ­Œå”±éŸ³å£°åˆæˆãŒå¯èƒ½ã€‚
 */
export type SpeakerStyleType = (typeof SpeakerStyleType)[keyof typeof SpeakerStyleType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerStyleType = {
  talk: 'talk',
  singing_teacher: 'singing_teacher',
  frame_decode: 'frame_decode',
  sing: 'sing',
} as const;

/**
 * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ«æƒ…å ±
 */
export interface SpeakerStyle {
  /** ã‚¹ã‚¿ã‚¤ãƒ«ID */
  id: number;
  /** ã‚¹ã‚¿ã‚¤ãƒ«å */
  name: string;
  /** ã‚¹ã‚¿ã‚¤ãƒ«ã®ç¨®é¡ã€‚talk:éŸ³å£°åˆæˆã‚¯ã‚¨ãƒªã®ä½œæˆã¨éŸ³å£°åˆæˆãŒå¯èƒ½ã€‚singing_teacher:æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®ä½œæˆãŒå¯èƒ½ã€‚frame_decode:æ­Œå”±éŸ³å£°åˆæˆãŒå¯èƒ½ã€‚sing:æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®ä½œæˆã¨æ­Œå”±éŸ³å£°åˆæˆãŒå¯èƒ½ã€‚ */
  type?: SpeakerStyleType;
}

/**
 * ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°æ©Ÿèƒ½ã¸ã®å¯¾å¿œã€‚'ALL' ã¯ã€Œå…¨ã¦è¨±å¯ã€ã€'SELF_ONLY' ã¯ã€ŒåŒã˜ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å†…ã§ã®ã¿è¨±å¯ã€ã€'NOTHING' ã¯ã€Œå…¨ã¦ç¦æ­¢ã€
 */
export type SpeakerSupportedFeaturesPermittedSynthesisMorphing =
  (typeof SpeakerSupportedFeaturesPermittedSynthesisMorphing)[keyof typeof SpeakerSupportedFeaturesPermittedSynthesisMorphing];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerSupportedFeaturesPermittedSynthesisMorphing = {
  ALL: 'ALL',
  SELF_ONLY: 'SELF_ONLY',
  NOTHING: 'NOTHING',
} as const;

/**
 * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¯¾å¿œæ©Ÿèƒ½ã®æƒ…å ±
 */
export interface SpeakerSupportedFeatures {
  /** ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°æ©Ÿèƒ½ã¸ã®å¯¾å¿œã€‚'ALL' ã¯ã€Œå…¨ã¦è¨±å¯ã€ã€'SELF_ONLY' ã¯ã€ŒåŒã˜ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å†…ã§ã®ã¿è¨±å¯ã€ã€'NOTHING' ã¯ã€Œå…¨ã¦ç¦æ­¢ã€ */
  permitted_synthesis_morphing?: SpeakerSupportedFeaturesPermittedSynthesisMorphing;
}

/**
 * ã‚¹ã‚¿ã‚¤ãƒ«ã®è¿½åŠ æƒ…å ±
 */
export interface StyleInfo {
  /** ã“ã®ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã‚‚ã®ã€ã‚ã‚‹ã„ã¯URL */
  icon: string;
  /** ã‚¹ã‚¿ã‚¤ãƒ«ID */
  id: number;
  /** ã“ã®ã‚¹ã‚¿ã‚¤ãƒ«ã®ç«‹ã¡çµµç”»åƒã‚’base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã‚‚ã®ã€ã‚ã‚‹ã„ã¯URL */
  portrait?: string;
  /** ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã‚’base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã‚‚ã®ã€ã‚ã‚‹ã„ã¯URL */
  voice_samples: string[];
}

/**
 * å¯¾å¿œã—ã¦ã„ã‚‹ãƒ‡ãƒã‚¤ã‚¹ã®æƒ…å ±ã€‚
 */
export interface SupportedDevicesInfo {
  /** CPUã«å¯¾å¿œã—ã¦ã„ã‚‹ã‹ */
  cpu: boolean;
  /** CUDA(Nvidia GPU)ã«å¯¾å¿œã—ã¦ã„ã‚‹ã‹ */
  cuda: boolean;
  /** DirectML(Nvidia GPU/Radeon GPUç­‰)ã«å¯¾å¿œã—ã¦ã„ã‚‹ã‹ */
  dml: boolean;
}

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³ãŒæŒã¤æ©Ÿèƒ½ã®ä¸€è¦§ã€‚
 */
export interface SupportedFeatures {
  /** å…¨ä½“ã®æŠ‘æšã®èª¿æ•´ */
  adjust_intonation_scale: boolean;
  /** ãƒ¢ãƒ¼ãƒ©ã”ã¨ã®éŸ³é«˜ã®èª¿æ•´ */
  adjust_mora_pitch: boolean;
  /** å¥èª­ç‚¹ãªã©ã®ç„¡éŸ³æ™‚é–“ã®èª¿æ•´ */
  adjust_pause_length?: boolean;
  /** éŸ³ç´ ã”ã¨ã®é•·ã•ã®èª¿æ•´ */
  adjust_phoneme_length: boolean;
  /** å…¨ä½“ã®éŸ³é«˜ã®èª¿æ•´ */
  adjust_pitch_scale: boolean;
  /** å…¨ä½“ã®è©±é€Ÿã®èª¿æ•´ */
  adjust_speed_scale: boolean;
  /** å…¨ä½“ã®éŸ³é‡ã®èª¿æ•´ */
  adjust_volume_scale: boolean;
  /** æœªçŸ¥ã®è‹±å˜èªã‚’ã‚«ã‚¿ã‚«ãƒŠèª­ã¿ã«å¤‰æ› */
  apply_katakana_english?: boolean;
  /** ç–‘å•æ–‡ã®è‡ªå‹•èª¿æ•´ */
  interrogative_upspeak: boolean;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ« */
  manage_library?: boolean;
  /** ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’URLã§è¿”é€ */
  return_resource_url?: boolean;
  /** æ­Œå”±éŸ³å£°åˆæˆ */
  sing?: boolean;
  /** 2ç¨®é¡ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã—ãŸéŸ³å£°ã‚’åˆæˆ */
  synthesis_morphing: boolean;
}

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆæƒ…å ±ã€‚
 */
export interface UpdateInfo {
  /** è²¢çŒ®è€…å */
  contributors?: string[];
  /** ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã®è©³ç´°ã«ã¤ã„ã¦ã®èª¬æ˜ */
  descriptions: string[];
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³å */
  version: string;
}

/**
 * è¾æ›¸ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«ä½¿ã‚ã‚Œã‚‹æƒ…å ±ã€‚
 */
export interface UserDictWord {
  /** ã‚¢ã‚¯ã‚»ãƒ³ãƒˆçµåˆè¦å‰‡ */
  accent_associative_rule: string;
  /** ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå‹ */
  accent_type: number;
  /** æ–‡è„ˆID */
  context_id?: number;
  /** æ´»ç”¨å½¢ */
  inflectional_form: string;
  /** æ´»ç”¨å‹ */
  inflectional_type: string;
  /** ãƒ¢ãƒ¼ãƒ©æ•° */
  mora_count?: number;
  /** å“è© */
  part_of_speech: string;
  /** å“è©ç´°åˆ†é¡1 */
  part_of_speech_detail_1: string;
  /** å“è©ç´°åˆ†é¡2 */
  part_of_speech_detail_2: string;
  /** å“è©ç´°åˆ†é¡3 */
  part_of_speech_detail_3: string;
  /**
   * å„ªå…ˆåº¦
   * @minimum 0
   * @maximum 10
   */
  priority: number;
  /** ç™ºéŸ³ */
  pronunciation: string;
  /** åŸå½¢ */
  stem: string;
  /** è¡¨å±¤å½¢ */
  surface: string;
  /** èª­ã¿ */
  yomi: string;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * vvlib(VOICEVOX Library)ã«é–¢ã™ã‚‹æƒ…å ±ã€‚
 */
export interface VvlibManifest {
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒ–ãƒ©ãƒ³ãƒ‰å */
  brand_name: string;
  /** ã‚¨ãƒ³ã‚¸ãƒ³å */
  engine_name: string;
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®UUID */
  engine_uuid: string;
  /** ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  manifest_version: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå */
  name: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®UUID */
  uuid: string;
  /** éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  version: string;
}

/**
 * å“è©
 */
export type WordTypes = (typeof WordTypes)[keyof typeof WordTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WordTypes = {
  PROPER_NOUN: 'PROPER_NOUN',
  COMMON_NOUN: 'COMMON_NOUN',
  VERB: 'VERB',
  ADJECTIVE: 'ADJECTIVE',
  SUFFIX: 'SUFFIX',
} as const;

export type AccentPhrasesParams = {
  text: string;
  speaker: number;
  is_kana?: boolean;
  enable_katakana_english?: boolean;
  core_version?: string;
};

export type AudioQueryParams = {
  text: string;
  speaker: number;
  enable_katakana_english?: boolean;
  core_version?: string;
};

export type AudioQueryFromPresetParams = {
  text: string;
  preset_id: number;
  enable_katakana_english?: boolean;
  core_version?: string;
};

export type CancellableSynthesisParams = {
  speaker: number;
  enable_interrogative_upspeak?: boolean;
  core_version?: string;
};

export type DeletePresetParams = {
  /**
   * å‰Šé™¤ã™ã‚‹ãƒ—ãƒªã‚»ãƒƒãƒˆã®ãƒ—ãƒªã‚»ãƒƒãƒˆID
   */
  id: number;
};

export type FrameSynthesisParams = {
  speaker: number;
  core_version?: string;
};

export type ImportUserDictWordsParams = {
  /**
   * é‡è¤‡ã—ãŸã‚¨ãƒ³ãƒˆãƒªãŒã‚ã£ãŸå ´åˆã€ä¸Šæ›¸ãã™ã‚‹ã‹ã©ã†ã‹
   */
  override: boolean;
};

/**
 * ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã®ãƒ‡ãƒ¼ã‚¿
 */
export type ImportUserDictWordsBody = { [key: string]: UserDictWord };

export type InitializeSpeakerParams = {
  speaker: number;
  /**
   * æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®ã‚¹ã‚¿ã‚¤ãƒ«ã®å†åˆæœŸåŒ–ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã‹ã©ã†ã‹
   */
  skip_reinit?: boolean;
  core_version?: string;
};

export type InstalledLibraries200 = { [key: string]: InstalledLibraryInfo };

export type IsInitializedSpeakerParams = {
  speaker: number;
  core_version?: string;
};

export type MoraDataParams = {
  speaker: number;
  core_version?: string;
};

export type MoraLengthParams = {
  speaker: number;
  core_version?: string;
};

export type MoraPitchParams = {
  speaker: number;
  core_version?: string;
};

export type MorphableTargetsParams = {
  core_version?: string;
};

export type MorphableTargets200Item = { [key: string]: MorphableTargetInfo };

export type MultiSynthesisParams = {
  speaker: number;
  /**
   * ç–‘å•ç³»ã®ãƒ†ã‚­ã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰èªå°¾ã‚’è‡ªå‹•èª¿æ•´ã™ã‚‹
   */
  enable_interrogative_upspeak?: boolean;
  core_version?: string;
};

export type SingFrameAudioQueryParams = {
  speaker: number;
  core_version?: string;
};

export type SingFrameF0Params = {
  speaker: number;
  core_version?: string;
};

export type SingFrameVolumeParams = {
  speaker: number;
  core_version?: string;
};

export type SingerInfoParams = {
  speaker_uuid: string;
  resource_format?: SingerInfoResourceFormat;
  core_version?: string;
};

export type SingerInfoResourceFormat =
  (typeof SingerInfoResourceFormat)[keyof typeof SingerInfoResourceFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SingerInfoResourceFormat = {
  base64: 'base64',
  url: 'url',
} as const;

export type SingersParams = {
  core_version?: string;
};

export type SpeakerInfoParams = {
  speaker_uuid: string;
  resource_format?: SpeakerInfoResourceFormat;
  core_version?: string;
};

export type SpeakerInfoResourceFormat =
  (typeof SpeakerInfoResourceFormat)[keyof typeof SpeakerInfoResourceFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerInfoResourceFormat = {
  base64: 'base64',
  url: 'url',
} as const;

export type SpeakersParams = {
  core_version?: string;
};

export type SupportedDevicesParams = {
  core_version?: string;
};

export type SynthesisParams = {
  speaker: number;
  /**
   * ç–‘å•ç³»ã®ãƒ†ã‚­ã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰èªå°¾ã‚’è‡ªå‹•èª¿æ•´ã™ã‚‹
   */
  enable_interrogative_upspeak?: boolean;
  core_version?: string;
};

export type SynthesisMorphingParams = {
  base_speaker: number;
  target_speaker: number;
  /**
   * @minimum 0
   * @maximum 1
   */
  morph_rate: number;
  /**
   * ç–‘å•ç³»ã®ãƒ†ã‚­ã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰èªå°¾ã‚’è‡ªå‹•èª¿æ•´ã™ã‚‹
   */
  enable_interrogative_upspeak?: boolean;
  core_version?: string;
};

export type GetUserDictWords200 = { [key: string]: UserDictWord };

export type AddUserDictWordParams = {
  /**
   * è¨€è‘‰ã®è¡¨å±¤å½¢
   */
  surface: string;
  /**
   * è¨€è‘‰ã®ç™ºéŸ³ï¼ˆã‚«ã‚¿ã‚«ãƒŠï¼‰
   */
  pronunciation: string;
  /**
   * ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå‹ï¼ˆéŸ³ãŒä¸‹ãŒã‚‹å ´æ‰€ã‚’æŒ‡ã™ï¼‰
   */
  accent_type: number;
  /**
   * PROPER_NOUNï¼ˆå›ºæœ‰åè©ï¼‰ã€COMMON_NOUNï¼ˆæ™®é€šåè©ï¼‰ã€VERBï¼ˆå‹•è©ï¼‰ã€ADJECTIVEï¼ˆå½¢å®¹è©ï¼‰ã€SUFFIXï¼ˆèªå°¾ï¼‰ã®ã„ãšã‚Œã‹
   */
  word_type?: WordTypes;
  /**
   * å˜èªã®å„ªå…ˆåº¦ï¼ˆ0ã‹ã‚‰10ã¾ã§ã®æ•´æ•°ï¼‰ã€‚æ•°å­—ãŒå¤§ãã„ã»ã©å„ªå…ˆåº¦ãŒé«˜ããªã‚‹ã€‚1ã‹ã‚‰9ã¾ã§ã®å€¤ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨
   * @minimum 0
   * @maximum 10
   */
  priority?: number;
};

export type RewriteUserDictWordParams = {
  /**
   * è¨€è‘‰ã®è¡¨å±¤å½¢
   */
  surface: string;
  /**
   * è¨€è‘‰ã®ç™ºéŸ³ï¼ˆã‚«ã‚¿ã‚«ãƒŠï¼‰
   */
  pronunciation: string;
  /**
   * ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå‹ï¼ˆéŸ³ãŒä¸‹ãŒã‚‹å ´æ‰€ã‚’æŒ‡ã™ï¼‰
   */
  accent_type: number;
  /**
   * PROPER_NOUNï¼ˆå›ºæœ‰åè©ï¼‰ã€COMMON_NOUNï¼ˆæ™®é€šåè©ï¼‰ã€VERBï¼ˆå‹•è©ï¼‰ã€ADJECTIVEï¼ˆå½¢å®¹è©ï¼‰ã€SUFFIXï¼ˆèªå°¾ï¼‰ã®ã„ãšã‚Œã‹
   */
  word_type?: WordTypes;
  /**
   * å˜èªã®å„ªå…ˆåº¦ï¼ˆ0ã‹ã‚‰10ã¾ã§ã®æ•´æ•°ï¼‰ã€‚æ•°å­—ãŒå¤§ãã„ã»ã©å„ªå…ˆåº¦ãŒé«˜ããªã‚‹ã€‚1ã‹ã‚‰9ã¾ã§ã®å€¤ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã€‚
   * @minimum 0
   * @maximum 10
   */
  priority?: number;
};

export type ValidateKanaParams = {
  /**
   * åˆ¤å®šã™ã‚‹å¯¾è±¡ã®æ–‡å­—åˆ—
   */
  text: string;
};

/**
 * ãƒãƒ¼ã‚¿ãƒ«ãƒšãƒ¼ã‚¸ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Get Portal Page
 */
export type getPortalPageResponse200 = {
  data: string;
  status: 200;
};

export type getPortalPageResponseSuccess = getPortalPageResponse200 & {
  headers: Headers;
};

export type getPortalPageResponse = getPortalPageResponseSuccess;

export const getGetPortalPageUrl = () => {
  return `/`;
};

export const getPortalPage = async (options?: RequestInit): Promise<getPortalPageResponse> => {
  const res = await fetch(getGetPortalPageUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getPortalPageResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getPortalPageResponse;
};

/**
 * ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‚’å¾—ã¾ã™ã€‚

is_kanaãŒ`true`ã®ã¨ãã€ãƒ†ã‚­ã‚¹ãƒˆã¯æ¬¡ã®AquesTalk é¢¨è¨˜æ³•ã§è§£é‡ˆã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯`false`ã§ã™ã€‚
* å…¨ã¦ã®ã‚«ãƒŠã¯ã‚«ã‚¿ã‚«ãƒŠã§è¨˜è¿°ã•ã‚Œã‚‹
* ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã¯`/`ã¾ãŸã¯`ã€`ã§åŒºåˆ‡ã‚‹ã€‚`ã€`ã§åŒºåˆ‡ã£ãŸå ´åˆã«é™ã‚Šç„¡éŸ³åŒºé–“ãŒæŒ¿å…¥ã•ã‚Œã‚‹ã€‚
* ã‚«ãƒŠã®æ‰‹å‰ã«`_`ã‚’å…¥ã‚Œã‚‹ã¨ãã®ã‚«ãƒŠã¯ç„¡å£°åŒ–ã•ã‚Œã‚‹
* ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä½ç½®ã‚’`'`ã§æŒ‡å®šã™ã‚‹ã€‚å…¨ã¦ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã«ã¯ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä½ç½®ã‚’1ã¤æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
* ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥æœ«ã«`ï¼Ÿ`(å…¨è§’)ã‚’å…¥ã‚Œã‚‹ã“ã¨ã«ã‚ˆã‚Šç–‘å•æ–‡ã®ç™ºéŸ³ãŒã§ãã‚‹ã€‚
enable_katakana_englishãŒ`true`ã®ã¨ãã€ãƒ†ã‚­ã‚¹ãƒˆä¸­ã®èª­ã¿ãŒä¸æ˜ãªè‹±å˜èªã‚’ã‚«ã‚¿ã‚«ãƒŠèª­ã¿ã«ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯`true`ã§ã™ã€‚
is_kanaãŒ`true`ã®ã¨ãã€enable_katakana_englishã®å€¤ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚
 * @summary ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‚’å¾—ã‚‹
 */
export type accentPhrasesResponse200 = {
  data: AccentPhrase[];
  status: 200;
};

export type accentPhrasesResponse400 = {
  data: ParseKanaBadRequest;
  status: 400;
};

export type accentPhrasesResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type accentPhrasesResponseSuccess = accentPhrasesResponse200 & {
  headers: Headers;
};
export type accentPhrasesResponseError = (accentPhrasesResponse400 | accentPhrasesResponse422) & {
  headers: Headers;
};

export type accentPhrasesResponse = accentPhrasesResponseSuccess | accentPhrasesResponseError;

export const getAccentPhrasesUrl = (params: AccentPhrasesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/accent_phrases?${stringifiedParams}` : `/accent_phrases`;
};

export const accentPhrases = async (
  params: AccentPhrasesParams,
  options?: RequestInit
): Promise<accentPhrasesResponse> => {
  const res = await fetch(getAccentPhrasesUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: accentPhrasesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as accentPhrasesResponse;
};

/**
 * æ–°ã—ã„ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚
 * @summary Add Preset
 */
export type addPresetResponse200 = {
  data: number;
  status: 200;
};

export type addPresetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type addPresetResponseSuccess = addPresetResponse200 & {
  headers: Headers;
};
export type addPresetResponseError = addPresetResponse422 & {
  headers: Headers;
};

export type addPresetResponse = addPresetResponseSuccess | addPresetResponseError;

export const getAddPresetUrl = () => {
  return `/add_preset`;
};

export const addPreset = async (
  preset: Preset,
  options?: RequestInit
): Promise<addPresetResponse> => {
  const res = await fetch(getAddPresetUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(preset),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: addPresetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as addPresetResponse;
};

/**
 * éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®åˆæœŸå€¤ã‚’å¾—ã¾ã™ã€‚ã“ã“ã§å¾—ã‚‰ã‚ŒãŸã‚¯ã‚¨ãƒªã¯ãã®ã¾ã¾éŸ³å£°åˆæˆã«åˆ©ç”¨ã§ãã¾ã™ã€‚å„å€¤ã®æ„å‘³ã¯`Schemas`ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
 * @summary éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ä½œæˆã™ã‚‹
 */
export type audioQueryResponse200 = {
  data: AudioQuery;
  status: 200;
};

export type audioQueryResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type audioQueryResponseSuccess = audioQueryResponse200 & {
  headers: Headers;
};
export type audioQueryResponseError = audioQueryResponse422 & {
  headers: Headers;
};

export type audioQueryResponse = audioQueryResponseSuccess | audioQueryResponseError;

export const getAudioQueryUrl = (params: AudioQueryParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/audio_query?${stringifiedParams}` : `/audio_query`;
};

export const audioQuery = async (
  params: AudioQueryParams,
  options?: RequestInit
): Promise<audioQueryResponse> => {
  const res = await fetch(getAudioQueryUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: audioQueryResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as audioQueryResponse;
};

/**
 * éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®åˆæœŸå€¤ã‚’å¾—ã¾ã™ã€‚ã“ã“ã§å¾—ã‚‰ã‚ŒãŸã‚¯ã‚¨ãƒªã¯ãã®ã¾ã¾éŸ³å£°åˆæˆã«åˆ©ç”¨ã§ãã¾ã™ã€‚å„å€¤ã®æ„å‘³ã¯`Schemas`ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
 * @summary éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ç”¨ã„ã¦ä½œæˆã™ã‚‹
 */
export type audioQueryFromPresetResponse200 = {
  data: AudioQuery;
  status: 200;
};

export type audioQueryFromPresetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type audioQueryFromPresetResponseSuccess = audioQueryFromPresetResponse200 & {
  headers: Headers;
};
export type audioQueryFromPresetResponseError = audioQueryFromPresetResponse422 & {
  headers: Headers;
};

export type audioQueryFromPresetResponse =
  | audioQueryFromPresetResponseSuccess
  | audioQueryFromPresetResponseError;

export const getAudioQueryFromPresetUrl = (params: AudioQueryFromPresetParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/audio_query_from_preset?${stringifiedParams}`
    : `/audio_query_from_preset`;
};

export const audioQueryFromPreset = async (
  params: AudioQueryFromPresetParams,
  options?: RequestInit
): Promise<audioQueryFromPresetResponse> => {
  const res = await fetch(getAudioQueryFromPresetUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: audioQueryFromPresetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as audioQueryFromPresetResponse;
};

/**
 * @summary éŸ³å£°åˆæˆã™ã‚‹ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ï¼‰
 */
export type cancellableSynthesisResponse200 = {
  data: Blob;
  status: 200;
};

export type cancellableSynthesisResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type cancellableSynthesisResponseSuccess = cancellableSynthesisResponse200 & {
  headers: Headers;
};
export type cancellableSynthesisResponseError = cancellableSynthesisResponse422 & {
  headers: Headers;
};

export type cancellableSynthesisResponse =
  | cancellableSynthesisResponseSuccess
  | cancellableSynthesisResponseError;

export const getCancellableSynthesisUrl = (params: CancellableSynthesisParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/cancellable_synthesis?${stringifiedParams}`
    : `/cancellable_synthesis`;
};

export const cancellableSynthesis = async (
  audioQuery: AudioQuery,
  params: CancellableSynthesisParams,
  options?: RequestInit
): Promise<cancellableSynthesisResponse> => {
  const res = await fetch(getCancellableSynthesisUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(audioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: cancellableSynthesisResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as cancellableSynthesisResponse;
};

/**
 * base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸwavãƒ‡ãƒ¼ã‚¿ã‚’ä¸€çºã‚ã«ã—ã€wavãƒ•ã‚¡ã‚¤ãƒ«ã§è¿”ã—ã¾ã™ã€‚
 * @summary base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸè¤‡æ•°ã®wavãƒ‡ãƒ¼ã‚¿ã‚’ä¸€ã¤ã«çµåˆã™ã‚‹
 */
export type connectWavesResponse200 = {
  data: Blob;
  status: 200;
};

export type connectWavesResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type connectWavesResponseSuccess = connectWavesResponse200 & {
  headers: Headers;
};
export type connectWavesResponseError = connectWavesResponse422 & {
  headers: Headers;
};

export type connectWavesResponse = connectWavesResponseSuccess | connectWavesResponseError;

export const getConnectWavesUrl = () => {
  return `/connect_waves`;
};

export const connectWaves = async (
  connectWavesBody: string[],
  options?: RequestInit
): Promise<connectWavesResponse> => {
  const res = await fetch(getConnectWavesUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(connectWavesBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: connectWavesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as connectWavesResponse;
};

/**
 * åˆ©ç”¨å¯èƒ½ãªã‚³ã‚¢ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™ã€‚
 * @summary Core Versions
 */
export type coreVersionsResponse200 = {
  data: string[];
  status: 200;
};

export type coreVersionsResponseSuccess = coreVersionsResponse200 & {
  headers: Headers;
};

export type coreVersionsResponse = coreVersionsResponseSuccess;

export const getCoreVersionsUrl = () => {
  return `/core_versions`;
};

export const coreVersions = async (options?: RequestInit): Promise<coreVersionsResponse> => {
  const res = await fetch(getCoreVersionsUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: coreVersionsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as coreVersionsResponse;
};

/**
 * æ—¢å­˜ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã€‚
 * @summary Delete Preset
 */
export type deletePresetResponse204 = {
  data: void;
  status: 204;
};

export type deletePresetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deletePresetResponseSuccess = deletePresetResponse204 & {
  headers: Headers;
};
export type deletePresetResponseError = deletePresetResponse422 & {
  headers: Headers;
};

export type deletePresetResponse = deletePresetResponseSuccess | deletePresetResponseError;

export const getDeletePresetUrl = (params: DeletePresetParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/delete_preset?${stringifiedParams}` : `/delete_preset`;
};

export const deletePreset = async (
  params: DeletePresetParams,
  options?: RequestInit
): Promise<deletePresetResponse> => {
  const res = await fetch(getDeletePresetUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deletePresetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as deletePresetResponse;
};

/**
 * ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªéŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Downloadable Libraries
 */
export type downloadableLibrariesResponse200 = {
  data: DownloadableLibraryInfo[];
  status: 200;
};

export type downloadableLibrariesResponseSuccess = downloadableLibrariesResponse200 & {
  headers: Headers;
};

export type downloadableLibrariesResponse = downloadableLibrariesResponseSuccess;

export const getDownloadableLibrariesUrl = () => {
  return `/downloadable_libraries`;
};

export const downloadableLibraries = async (
  options?: RequestInit
): Promise<downloadableLibrariesResponse> => {
  const res = await fetch(getDownloadableLibrariesUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: downloadableLibrariesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as downloadableLibrariesResponse;
};

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã‚’å–å¾—ã—ã¾ã™ã€‚
 * @summary Engine Manifest
 */
export type engineManifestResponse200 = {
  data: EngineManifest;
  status: 200;
};

export type engineManifestResponseSuccess = engineManifestResponse200 & {
  headers: Headers;
};

export type engineManifestResponse = engineManifestResponseSuccess;

export const getEngineManifestUrl = () => {
  return `/engine_manifest`;
};

export const engineManifest = async (options?: RequestInit): Promise<engineManifestResponse> => {
  const res = await fetch(getEngineManifestUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: engineManifestResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as engineManifestResponse;
};

/**
 * æ­Œå”±éŸ³å£°åˆæˆã‚’è¡Œã„ã¾ã™ã€‚
 * @summary Frame Synthesis
 */
export type frameSynthesisResponse200 = {
  data: Blob;
  status: 200;
};

export type frameSynthesisResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type frameSynthesisResponseSuccess = frameSynthesisResponse200 & {
  headers: Headers;
};
export type frameSynthesisResponseError = frameSynthesisResponse422 & {
  headers: Headers;
};

export type frameSynthesisResponse = frameSynthesisResponseSuccess | frameSynthesisResponseError;

export const getFrameSynthesisUrl = (params: FrameSynthesisParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/frame_synthesis?${stringifiedParams}`
    : `/frame_synthesis`;
};

export const frameSynthesis = async (
  frameAudioQuery: FrameAudioQuery,
  params: FrameSynthesisParams,
  options?: RequestInit
): Promise<frameSynthesisResponse> => {
  const res = await fetch(getFrameSynthesisUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(frameAudioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: frameSynthesisResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as frameSynthesisResponse;
};

/**
 * ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
 * @summary Import User Dict Words
 */
export type importUserDictWordsResponse204 = {
  data: void;
  status: 204;
};

export type importUserDictWordsResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type importUserDictWordsResponseSuccess = importUserDictWordsResponse204 & {
  headers: Headers;
};
export type importUserDictWordsResponseError = importUserDictWordsResponse422 & {
  headers: Headers;
};

export type importUserDictWordsResponse =
  | importUserDictWordsResponseSuccess
  | importUserDictWordsResponseError;

export const getImportUserDictWordsUrl = (params: ImportUserDictWordsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/import_user_dict?${stringifiedParams}`
    : `/import_user_dict`;
};

export const importUserDictWords = async (
  importUserDictWordsBody: ImportUserDictWordsBody,
  params: ImportUserDictWordsParams,
  options?: RequestInit
): Promise<importUserDictWordsResponse> => {
  const res = await fetch(getImportUserDictWordsUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(importUserDictWordsBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: importUserDictWordsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as importUserDictWordsResponse;
};

/**
 * æŒ‡å®šã•ã‚ŒãŸã‚¹ã‚¿ã‚¤ãƒ«ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚

å®Ÿè¡Œã—ãªãã¦ã‚‚ä»–ã®APIã¯ä½¿ç”¨ã§ãã¾ã™ãŒã€åˆå›å®Ÿè¡Œæ™‚ã«æ™‚é–“ãŒã‹ã‹ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
 * @summary Initialize Speaker
 */
export type initializeSpeakerResponse204 = {
  data: void;
  status: 204;
};

export type initializeSpeakerResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type initializeSpeakerResponseSuccess = initializeSpeakerResponse204 & {
  headers: Headers;
};
export type initializeSpeakerResponseError = initializeSpeakerResponse422 & {
  headers: Headers;
};

export type initializeSpeakerResponse =
  | initializeSpeakerResponseSuccess
  | initializeSpeakerResponseError;

export const getInitializeSpeakerUrl = (params: InitializeSpeakerParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/initialize_speaker?${stringifiedParams}`
    : `/initialize_speaker`;
};

export const initializeSpeaker = async (
  params: InitializeSpeakerParams,
  options?: RequestInit
): Promise<initializeSpeakerResponse> => {
  const res = await fetch(getInitializeSpeakerUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: initializeSpeakerResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as initializeSpeakerResponse;
};

/**
 * éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚

éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã¨ã—ã¦é€ä¿¡ã—ã¦ãã ã•ã„ã€‚
 * @summary Install Library
 */
export type installLibraryResponse204 = {
  data: void;
  status: 204;
};

export type installLibraryResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type installLibraryResponseSuccess = installLibraryResponse204 & {
  headers: Headers;
};
export type installLibraryResponseError = installLibraryResponse422 & {
  headers: Headers;
};

export type installLibraryResponse = installLibraryResponseSuccess | installLibraryResponseError;

export const getInstallLibraryUrl = (libraryUuid: string) => {
  return `/install_library/${libraryUuid}`;
};

export const installLibrary = async (
  libraryUuid: string,
  options?: RequestInit
): Promise<installLibraryResponse> => {
  const res = await fetch(getInstallLibraryUrl(libraryUuid), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: installLibraryResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as installLibraryResponse;
};

/**
 * ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãŸéŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Installed Libraries
 */
export type installedLibrariesResponse200 = {
  data: InstalledLibraries200;
  status: 200;
};

export type installedLibrariesResponseSuccess = installedLibrariesResponse200 & {
  headers: Headers;
};

export type installedLibrariesResponse = installedLibrariesResponseSuccess;

export const getInstalledLibrariesUrl = () => {
  return `/installed_libraries`;
};

export const installedLibraries = async (
  options?: RequestInit
): Promise<installedLibrariesResponse> => {
  const res = await fetch(getInstalledLibrariesUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: installedLibrariesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as installedLibrariesResponse;
};

/**
 * æŒ‡å®šã•ã‚ŒãŸã‚¹ã‚¿ã‚¤ãƒ«ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Is Initialized Speaker
 */
export type isInitializedSpeakerResponse200 = {
  data: boolean;
  status: 200;
};

export type isInitializedSpeakerResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type isInitializedSpeakerResponseSuccess = isInitializedSpeakerResponse200 & {
  headers: Headers;
};
export type isInitializedSpeakerResponseError = isInitializedSpeakerResponse422 & {
  headers: Headers;
};

export type isInitializedSpeakerResponse =
  | isInitializedSpeakerResponseSuccess
  | isInitializedSpeakerResponseError;

export const getIsInitializedSpeakerUrl = (params: IsInitializedSpeakerParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/is_initialized_speaker?${stringifiedParams}`
    : `/is_initialized_speaker`;
};

export const isInitializedSpeaker = async (
  params: IsInitializedSpeakerParams,
  options?: RequestInit
): Promise<isInitializedSpeakerResponse> => {
  const res = await fetch(getIsInitializedSpeakerUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: isInitializedSpeakerResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as isInitializedSpeakerResponse;
};

/**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³ç´ ã®é•·ã•ã¨éŸ³é«˜ã‚’å¾—ã‚‹
 */
export type moraDataResponse200 = {
  data: AccentPhrase[];
  status: 200;
};

export type moraDataResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type moraDataResponseSuccess = moraDataResponse200 & {
  headers: Headers;
};
export type moraDataResponseError = moraDataResponse422 & {
  headers: Headers;
};

export type moraDataResponse = moraDataResponseSuccess | moraDataResponseError;

export const getMoraDataUrl = (params: MoraDataParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/mora_data?${stringifiedParams}` : `/mora_data`;
};

export const moraData = async (
  accentPhrase: AccentPhrase[],
  params: MoraDataParams,
  options?: RequestInit
): Promise<moraDataResponse> => {
  const res = await fetch(getMoraDataUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(accentPhrase),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: moraDataResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as moraDataResponse;
};

/**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³ç´ ã®é•·ã•ã‚’å¾—ã‚‹
 */
export type moraLengthResponse200 = {
  data: AccentPhrase[];
  status: 200;
};

export type moraLengthResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type moraLengthResponseSuccess = moraLengthResponse200 & {
  headers: Headers;
};
export type moraLengthResponseError = moraLengthResponse422 & {
  headers: Headers;
};

export type moraLengthResponse = moraLengthResponseSuccess | moraLengthResponseError;

export const getMoraLengthUrl = (params: MoraLengthParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/mora_length?${stringifiedParams}` : `/mora_length`;
};

export const moraLength = async (
  accentPhrase: AccentPhrase[],
  params: MoraLengthParams,
  options?: RequestInit
): Promise<moraLengthResponse> => {
  const res = await fetch(getMoraLengthUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(accentPhrase),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: moraLengthResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as moraLengthResponse;
};

/**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³é«˜ã‚’å¾—ã‚‹
 */
export type moraPitchResponse200 = {
  data: AccentPhrase[];
  status: 200;
};

export type moraPitchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type moraPitchResponseSuccess = moraPitchResponse200 & {
  headers: Headers;
};
export type moraPitchResponseError = moraPitchResponse422 & {
  headers: Headers;
};

export type moraPitchResponse = moraPitchResponseSuccess | moraPitchResponseError;

export const getMoraPitchUrl = (params: MoraPitchParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/mora_pitch?${stringifiedParams}` : `/mora_pitch`;
};

export const moraPitch = async (
  accentPhrase: AccentPhrase[],
  params: MoraPitchParams,
  options?: RequestInit
): Promise<moraPitchResponse> => {
  const res = await fetch(getMoraPitchUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(accentPhrase),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: moraPitchResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as moraPitchResponse;
};

/**
 * æŒ‡å®šã•ã‚ŒãŸãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ«ã«å¯¾ã—ã¦ã‚¨ãƒ³ã‚¸ãƒ³å†…ã®å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°æ©Ÿèƒ½ã‚’åˆ©ç”¨å¯èƒ½ã‹è¿”ã—ã¾ã™ã€‚

ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã®è¨±å¯/ç¦æ­¢ã¯`/speakers`ã®`speaker.supported_features.synthesis_morphing`ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚
ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã€ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ãŒè¨±å¯ã•ã‚Œã¦ã„ã‚‹ã¨ã¿ãªã—ã¾ã™ã€‚
è¿”ã‚Šå€¤ã®ã‚¹ã‚¿ã‚¤ãƒ«IDã¯stringå‹ãªã®ã§æ³¨æ„ã€‚
 * @summary æŒ‡å®šã—ãŸã‚¹ã‚¿ã‚¤ãƒ«ã«å¯¾ã—ã¦ã‚¨ãƒ³ã‚¸ãƒ³å†…ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ãŒå¯èƒ½ã‹åˆ¤å®šã™ã‚‹
 */
export type morphableTargetsResponse200 = {
  data: MorphableTargets200Item[];
  status: 200;
};

export type morphableTargetsResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type morphableTargetsResponseSuccess = morphableTargetsResponse200 & {
  headers: Headers;
};
export type morphableTargetsResponseError = morphableTargetsResponse422 & {
  headers: Headers;
};

export type morphableTargetsResponse =
  | morphableTargetsResponseSuccess
  | morphableTargetsResponseError;

export const getMorphableTargetsUrl = (params?: MorphableTargetsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/morphable_targets?${stringifiedParams}`
    : `/morphable_targets`;
};

export const morphableTargets = async (
  morphableTargetsBody: number[],
  params?: MorphableTargetsParams,
  options?: RequestInit
): Promise<morphableTargetsResponse> => {
  const res = await fetch(getMorphableTargetsUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(morphableTargetsBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: morphableTargetsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as morphableTargetsResponse;
};

/**
 * @summary è¤‡æ•°ã¾ã¨ã‚ã¦éŸ³å£°åˆæˆã™ã‚‹
 */
export type multiSynthesisResponse200 = {
  data: Blob;
  status: 200;
};

export type multiSynthesisResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type multiSynthesisResponseSuccess = multiSynthesisResponse200 & {
  headers: Headers;
};
export type multiSynthesisResponseError = multiSynthesisResponse422 & {
  headers: Headers;
};

export type multiSynthesisResponse = multiSynthesisResponseSuccess | multiSynthesisResponseError;

export const getMultiSynthesisUrl = (params: MultiSynthesisParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/multi_synthesis?${stringifiedParams}`
    : `/multi_synthesis`;
};

export const multiSynthesis = async (
  audioQuery: AudioQuery[],
  params: MultiSynthesisParams,
  options?: RequestInit
): Promise<multiSynthesisResponse> => {
  const res = await fetch(getMultiSynthesisUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(audioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: multiSynthesisResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as multiSynthesisResponse;
};

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³ãŒä¿æŒã—ã¦ã„ã‚‹ãƒ—ãƒªã‚»ãƒƒãƒˆã®è¨­å®šã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Get Presets
 */
export type getPresetsResponse200 = {
  data: Preset[];
  status: 200;
};

export type getPresetsResponseSuccess = getPresetsResponse200 & {
  headers: Headers;
};

export type getPresetsResponse = getPresetsResponseSuccess;

export const getGetPresetsUrl = () => {
  return `/presets`;
};

export const getPresets = async (options?: RequestInit): Promise<getPresetsResponse> => {
  const res = await fetch(getGetPresetsUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getPresetsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getPresetsResponse;
};

/**
 * è¨­å®šãƒšãƒ¼ã‚¸ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Setting Get
 */
export type settingGetResponse200 = {
  data: void;
  status: 200;
};

export type settingGetResponseSuccess = settingGetResponse200 & {
  headers: Headers;
};

export type settingGetResponse = settingGetResponseSuccess;

export const getSettingGetUrl = () => {
  return `/setting`;
};

export const settingGet = async (options?: RequestInit): Promise<settingGetResponse> => {
  const res = await fetch(getSettingGetUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: settingGetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as settingGetResponse;
};

/**
 * è¨­å®šã‚’æ›´æ–°ã—ã¾ã™ã€‚
 * @summary Setting Post
 */
export type settingPostResponse204 = {
  data: void;
  status: 204;
};

export type settingPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type settingPostResponseSuccess = settingPostResponse204 & {
  headers: Headers;
};
export type settingPostResponseError = settingPostResponse422 & {
  headers: Headers;
};

export type settingPostResponse = settingPostResponseSuccess | settingPostResponseError;

export const getSettingPostUrl = () => {
  return `/setting`;
};

export const settingPost = async (
  bodySettingPostSettingPost: BodySettingPostSettingPost,
  options?: RequestInit
): Promise<settingPostResponse> => {
  const formUrlEncoded = new URLSearchParams();
  if (bodySettingPostSettingPost.allow_origin !== undefined) {
    formUrlEncoded.append(`allow_origin`, bodySettingPostSettingPost.allow_origin);
  }
  formUrlEncoded.append(`cors_policy_mode`, bodySettingPostSettingPost.cors_policy_mode);

  const res = await fetch(getSettingPostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: formUrlEncoded,
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: settingPostResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as settingPostResponse;
};

/**
 * æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®åˆæœŸå€¤ã‚’å¾—ã¾ã™ã€‚ã“ã“ã§å¾—ã‚‰ã‚ŒãŸã‚¯ã‚¨ãƒªã¯ãã®ã¾ã¾æ­Œå”±éŸ³å£°åˆæˆã«åˆ©ç”¨ã§ãã¾ã™ã€‚å„å€¤ã®æ„å‘³ã¯`Schemas`ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
 * @summary æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ä½œæˆã™ã‚‹
 */
export type singFrameAudioQueryResponse200 = {
  data: FrameAudioQuery;
  status: 200;
};

export type singFrameAudioQueryResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singFrameAudioQueryResponseSuccess = singFrameAudioQueryResponse200 & {
  headers: Headers;
};
export type singFrameAudioQueryResponseError = singFrameAudioQueryResponse422 & {
  headers: Headers;
};

export type singFrameAudioQueryResponse =
  | singFrameAudioQueryResponseSuccess
  | singFrameAudioQueryResponseError;

export const getSingFrameAudioQueryUrl = (params: SingFrameAudioQueryParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/sing_frame_audio_query?${stringifiedParams}`
    : `/sing_frame_audio_query`;
};

export const singFrameAudioQuery = async (
  score: Score,
  params: SingFrameAudioQueryParams,
  options?: RequestInit
): Promise<singFrameAudioQueryResponse> => {
  const res = await fetch(getSingFrameAudioQueryUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(score),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singFrameAudioQueryResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singFrameAudioQueryResponse;
};

/**
 * @summary æ¥½è­œãƒ»æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‹ã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®åŸºæœ¬å‘¨æ³¢æ•°ã‚’å¾—ã‚‹
 */
export type singFrameF0Response200 = {
  data: number[];
  status: 200;
};

export type singFrameF0Response422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singFrameF0ResponseSuccess = singFrameF0Response200 & {
  headers: Headers;
};
export type singFrameF0ResponseError = singFrameF0Response422 & {
  headers: Headers;
};

export type singFrameF0Response = singFrameF0ResponseSuccess | singFrameF0ResponseError;

export const getSingFrameF0Url = (params: SingFrameF0Params) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/sing_frame_f0?${stringifiedParams}` : `/sing_frame_f0`;
};

export const singFrameF0 = async (
  bodySingFrameF0SingFrameF0Post: BodySingFrameF0SingFrameF0Post,
  params: SingFrameF0Params,
  options?: RequestInit
): Promise<singFrameF0Response> => {
  const res = await fetch(getSingFrameF0Url(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(bodySingFrameF0SingFrameF0Post),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singFrameF0Response['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singFrameF0Response;
};

/**
 * @summary æ¥½è­œãƒ»æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‹ã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®éŸ³é‡ã‚’å¾—ã‚‹
 */
export type singFrameVolumeResponse200 = {
  data: number[];
  status: 200;
};

export type singFrameVolumeResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singFrameVolumeResponseSuccess = singFrameVolumeResponse200 & {
  headers: Headers;
};
export type singFrameVolumeResponseError = singFrameVolumeResponse422 & {
  headers: Headers;
};

export type singFrameVolumeResponse = singFrameVolumeResponseSuccess | singFrameVolumeResponseError;

export const getSingFrameVolumeUrl = (params: SingFrameVolumeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/sing_frame_volume?${stringifiedParams}`
    : `/sing_frame_volume`;
};

export const singFrameVolume = async (
  bodySingFrameVolumeSingFrameVolumePost: BodySingFrameVolumeSingFrameVolumePost,
  params: SingFrameVolumeParams,
  options?: RequestInit
): Promise<singFrameVolumeResponse> => {
  const res = await fetch(getSingFrameVolumeUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(bodySingFrameVolumeSingFrameVolumePost),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singFrameVolumeResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singFrameVolumeResponse;
};

/**
 * UUID ã§æŒ‡å®šã•ã‚ŒãŸæ­Œãˆã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚

ç”»åƒã‚„éŸ³å£°ã¯resource_formatã§æŒ‡å®šã—ãŸå½¢å¼ã§è¿”ã•ã‚Œã¾ã™ã€‚
 * @summary Singer Info
 */
export type singerInfoResponse200 = {
  data: SpeakerInfo;
  status: 200;
};

export type singerInfoResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singerInfoResponseSuccess = singerInfoResponse200 & {
  headers: Headers;
};
export type singerInfoResponseError = singerInfoResponse422 & {
  headers: Headers;
};

export type singerInfoResponse = singerInfoResponseSuccess | singerInfoResponseError;

export const getSingerInfoUrl = (params: SingerInfoParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/singer_info?${stringifiedParams}` : `/singer_info`;
};

export const singerInfo = async (
  params: SingerInfoParams,
  options?: RequestInit
): Promise<singerInfoResponse> => {
  const res = await fetch(getSingerInfoUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singerInfoResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singerInfoResponse;
};

/**
 * æ­Œãˆã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æƒ…å ±ã®ä¸€è¦§ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Singers
 */
export type singersResponse200 = {
  data: Speaker[];
  status: 200;
};

export type singersResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type singersResponseSuccess = singersResponse200 & {
  headers: Headers;
};
export type singersResponseError = singersResponse422 & {
  headers: Headers;
};

export type singersResponse = singersResponseSuccess | singersResponseError;

export const getSingersUrl = (params?: SingersParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/singers?${stringifiedParams}` : `/singers`;
};

export const singers = async (
  params?: SingersParams,
  options?: RequestInit
): Promise<singersResponse> => {
  const res = await fetch(getSingersUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: singersResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as singersResponse;
};

/**
 * UUID ã§æŒ‡å®šã•ã‚ŒãŸå–‹ã‚Œã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚

ç”»åƒã‚„éŸ³å£°ã¯resource_formatã§æŒ‡å®šã—ãŸå½¢å¼ã§è¿”ã•ã‚Œã¾ã™ã€‚
 * @summary Speaker Info
 */
export type speakerInfoResponse200 = {
  data: SpeakerInfo;
  status: 200;
};

export type speakerInfoResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type speakerInfoResponseSuccess = speakerInfoResponse200 & {
  headers: Headers;
};
export type speakerInfoResponseError = speakerInfoResponse422 & {
  headers: Headers;
};

export type speakerInfoResponse = speakerInfoResponseSuccess | speakerInfoResponseError;

export const getSpeakerInfoUrl = (params: SpeakerInfoParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/speaker_info?${stringifiedParams}` : `/speaker_info`;
};

export const speakerInfo = async (
  params: SpeakerInfoParams,
  options?: RequestInit
): Promise<speakerInfoResponse> => {
  const res = await fetch(getSpeakerInfoUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: speakerInfoResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as speakerInfoResponse;
};

/**
 * å–‹ã‚Œã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æƒ…å ±ã®ä¸€è¦§ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Speakers
 */
export type speakersResponse200 = {
  data: Speaker[];
  status: 200;
};

export type speakersResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type speakersResponseSuccess = speakersResponse200 & {
  headers: Headers;
};
export type speakersResponseError = speakersResponse422 & {
  headers: Headers;
};

export type speakersResponse = speakersResponseSuccess | speakersResponseError;

export const getSpeakersUrl = (params?: SpeakersParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/speakers?${stringifiedParams}` : `/speakers`;
};

export const speakers = async (
  params?: SpeakersParams,
  options?: RequestInit
): Promise<speakersResponse> => {
  const res = await fetch(getSpeakersUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: speakersResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as speakersResponse;
};

/**
 * å¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ã®ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™ã€‚
 * @summary Supported Devices
 */
export type supportedDevicesResponse200 = {
  data: SupportedDevicesInfo;
  status: 200;
};

export type supportedDevicesResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type supportedDevicesResponseSuccess = supportedDevicesResponse200 & {
  headers: Headers;
};
export type supportedDevicesResponseError = supportedDevicesResponse422 & {
  headers: Headers;
};

export type supportedDevicesResponse =
  | supportedDevicesResponseSuccess
  | supportedDevicesResponseError;

export const getSupportedDevicesUrl = (params?: SupportedDevicesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/supported_devices?${stringifiedParams}`
    : `/supported_devices`;
};

export const supportedDevices = async (
  params?: SupportedDevicesParams,
  options?: RequestInit
): Promise<supportedDevicesResponse> => {
  const res = await fetch(getSupportedDevicesUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: supportedDevicesResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as supportedDevicesResponse;
};

/**
 * @summary éŸ³å£°åˆæˆã™ã‚‹
 */
export type synthesisResponse200 = {
  data: Blob;
  status: 200;
};

export type synthesisResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type synthesisResponseSuccess = synthesisResponse200 & {
  headers: Headers;
};
export type synthesisResponseError = synthesisResponse422 & {
  headers: Headers;
};

export type synthesisResponse = synthesisResponseSuccess | synthesisResponseError;

export const getSynthesisUrl = (params: SynthesisParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/synthesis?${stringifiedParams}` : `/synthesis`;
};

export const synthesis = async (
  audioQuery: AudioQuery,
  params: SynthesisParams,
  options?: RequestInit
): Promise<synthesisResponse> => {
  const res = await fetch(getSynthesisUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(audioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: synthesisResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as synthesisResponse;
};

/**
 * æŒ‡å®šã•ã‚ŒãŸ2ç¨®é¡ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§éŸ³å£°ã‚’åˆæˆã€æŒ‡å®šã—ãŸå‰²åˆã§ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã—ãŸéŸ³å£°ã‚’å¾—ã¾ã™ã€‚

ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã®å‰²åˆã¯`morph_rate`ã§æŒ‡å®šã§ãã€0.0ã§ãƒ™ãƒ¼ã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ«ã€1.0ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ«ã«è¿‘ã¥ãã¾ã™ã€‚
 * @summary 2ç¨®é¡ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã—ãŸéŸ³å£°ã‚’åˆæˆã™ã‚‹
 */
export type synthesisMorphingResponse200 = {
  data: Blob;
  status: 200;
};

export type synthesisMorphingResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type synthesisMorphingResponseSuccess = synthesisMorphingResponse200 & {
  headers: Headers;
};
export type synthesisMorphingResponseError = synthesisMorphingResponse422 & {
  headers: Headers;
};

export type synthesisMorphingResponse =
  | synthesisMorphingResponseSuccess
  | synthesisMorphingResponseError;

export const getSynthesisMorphingUrl = (params: SynthesisMorphingParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/synthesis_morphing?${stringifiedParams}`
    : `/synthesis_morphing`;
};

export const synthesisMorphing = async (
  audioQuery: AudioQuery,
  params: SynthesisMorphingParams,
  options?: RequestInit
): Promise<synthesisMorphingResponse> => {
  const res = await fetch(getSynthesisMorphingUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(audioQuery),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: synthesisMorphingResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as synthesisMorphingResponse;
};

/**
 * éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
 * @summary Uninstall Library
 */
export type uninstallLibraryResponse204 = {
  data: void;
  status: 204;
};

export type uninstallLibraryResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type uninstallLibraryResponseSuccess = uninstallLibraryResponse204 & {
  headers: Headers;
};
export type uninstallLibraryResponseError = uninstallLibraryResponse422 & {
  headers: Headers;
};

export type uninstallLibraryResponse =
  | uninstallLibraryResponseSuccess
  | uninstallLibraryResponseError;

export const getUninstallLibraryUrl = (libraryUuid: string) => {
  return `/uninstall_library/${libraryUuid}`;
};

export const uninstallLibrary = async (
  libraryUuid: string,
  options?: RequestInit
): Promise<uninstallLibraryResponse> => {
  const res = await fetch(getUninstallLibraryUrl(libraryUuid), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: uninstallLibraryResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as uninstallLibraryResponse;
};

/**
 * æ—¢å­˜ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’æ›´æ–°ã—ã¾ã™ã€‚
 * @summary Update Preset
 */
export type updatePresetResponse200 = {
  data: number;
  status: 200;
};

export type updatePresetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updatePresetResponseSuccess = updatePresetResponse200 & {
  headers: Headers;
};
export type updatePresetResponseError = updatePresetResponse422 & {
  headers: Headers;
};

export type updatePresetResponse = updatePresetResponseSuccess | updatePresetResponseError;

export const getUpdatePresetUrl = () => {
  return `/update_preset`;
};

export const updatePreset = async (
  preset: Preset,
  options?: RequestInit
): Promise<updatePresetResponse> => {
  const res = await fetch(getUpdatePresetUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(preset),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updatePresetResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as updatePresetResponse;
};

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å˜èªã®ä¸€è¦§ã‚’è¿”ã—ã¾ã™ã€‚

å˜èªã®è¡¨å±¤å½¢(surface)ã¯æ­£è¦åŒ–æ¸ˆã¿ã®ç‰©ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Get User Dict Words
 */
export type getUserDictWordsResponse200 = {
  data: GetUserDictWords200;
  status: 200;
};

export type getUserDictWordsResponseSuccess = getUserDictWordsResponse200 & {
  headers: Headers;
};

export type getUserDictWordsResponse = getUserDictWordsResponseSuccess;

export const getGetUserDictWordsUrl = () => {
  return `/user_dict`;
};

export const getUserDictWords = async (
  options?: RequestInit
): Promise<getUserDictWordsResponse> => {
  const res = await fetch(getGetUserDictWordsUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getUserDictWordsResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getUserDictWordsResponse;
};

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã«è¨€è‘‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚
 * @summary Add User Dict Word
 */
export type addUserDictWordResponse200 = {
  data: string;
  status: 200;
};

export type addUserDictWordResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type addUserDictWordResponseSuccess = addUserDictWordResponse200 & {
  headers: Headers;
};
export type addUserDictWordResponseError = addUserDictWordResponse422 & {
  headers: Headers;
};

export type addUserDictWordResponse = addUserDictWordResponseSuccess | addUserDictWordResponseError;

export const getAddUserDictWordUrl = (params: AddUserDictWordParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/user_dict_word?${stringifiedParams}` : `/user_dict_word`;
};

export const addUserDictWord = async (
  params: AddUserDictWordParams,
  options?: RequestInit
): Promise<addUserDictWordResponse> => {
  const res = await fetch(getAddUserDictWordUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: addUserDictWordResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as addUserDictWordResponse;
};

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹è¨€è‘‰ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
 * @summary Delete User Dict Word
 */
export type deleteUserDictWordResponse204 = {
  data: void;
  status: 204;
};

export type deleteUserDictWordResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deleteUserDictWordResponseSuccess = deleteUserDictWordResponse204 & {
  headers: Headers;
};
export type deleteUserDictWordResponseError = deleteUserDictWordResponse422 & {
  headers: Headers;
};

export type deleteUserDictWordResponse =
  | deleteUserDictWordResponseSuccess
  | deleteUserDictWordResponseError;

export const getDeleteUserDictWordUrl = (wordUuid: string) => {
  return `/user_dict_word/${wordUuid}`;
};

export const deleteUserDictWord = async (
  wordUuid: string,
  options?: RequestInit
): Promise<deleteUserDictWordResponse> => {
  const res = await fetch(getDeleteUserDictWordUrl(wordUuid), {
    ...options,
    method: 'DELETE',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteUserDictWordResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as deleteUserDictWordResponse;
};

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹è¨€è‘‰ã‚’æ›´æ–°ã—ã¾ã™ã€‚
 * @summary Rewrite User Dict Word
 */
export type rewriteUserDictWordResponse204 = {
  data: void;
  status: 204;
};

export type rewriteUserDictWordResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type rewriteUserDictWordResponseSuccess = rewriteUserDictWordResponse204 & {
  headers: Headers;
};
export type rewriteUserDictWordResponseError = rewriteUserDictWordResponse422 & {
  headers: Headers;
};

export type rewriteUserDictWordResponse =
  | rewriteUserDictWordResponseSuccess
  | rewriteUserDictWordResponseError;

export const getRewriteUserDictWordUrl = (wordUuid: string, params: RewriteUserDictWordParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user_dict_word/${wordUuid}?${stringifiedParams}`
    : `/user_dict_word/${wordUuid}`;
};

export const rewriteUserDictWord = async (
  wordUuid: string,
  params: RewriteUserDictWordParams,
  options?: RequestInit
): Promise<rewriteUserDictWordResponse> => {
  const res = await fetch(getRewriteUserDictWordUrl(wordUuid, params), {
    ...options,
    method: 'PUT',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: rewriteUserDictWordResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as rewriteUserDictWordResponse;
};

/**
 * ãƒ†ã‚­ã‚¹ãƒˆãŒAquesTalk é¢¨è¨˜æ³•ã«å¾“ã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚

å¾“ã£ã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãŒè¿”ã‚Šã¾ã™ã€‚
 * @summary ãƒ†ã‚­ã‚¹ãƒˆãŒAquesTalk é¢¨è¨˜æ³•ã«å¾“ã£ã¦ã„ã‚‹ã‹åˆ¤å®šã™ã‚‹
 */
export type validateKanaResponse200 = {
  data: boolean;
  status: 200;
};

export type validateKanaResponse400 = {
  data: ParseKanaBadRequest;
  status: 400;
};

export type validateKanaResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type validateKanaResponseSuccess = validateKanaResponse200 & {
  headers: Headers;
};
export type validateKanaResponseError = (validateKanaResponse400 | validateKanaResponse422) & {
  headers: Headers;
};

export type validateKanaResponse = validateKanaResponseSuccess | validateKanaResponseError;

export const getValidateKanaUrl = (params: ValidateKanaParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/validate_kana?${stringifiedParams}` : `/validate_kana`;
};

export const validateKana = async (
  params: ValidateKanaParams,
  options?: RequestInit
): Promise<validateKanaResponse> => {
  const res = await fetch(getValidateKanaUrl(params), {
    ...options,
    method: 'POST',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: validateKanaResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as validateKanaResponse;
};

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å–å¾—ã—ã¾ã™ã€‚
 * @summary Version
 */
export type versionResponse200 = {
  data: string;
  status: 200;
};

export type versionResponseSuccess = versionResponse200 & {
  headers: Headers;
};

export type versionResponse = versionResponseSuccess;

export const getVersionUrl = () => {
  return `/version`;
};

export const version = async (options?: RequestInit): Promise<versionResponse> => {
  const res = await fetch(getVersionUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: versionResponse['data'] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as versionResponse;
};
